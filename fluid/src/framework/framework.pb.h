// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: framework.proto

#ifndef PROTOBUF_framework_2eproto__INCLUDED
#define PROTOBUF_framework_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
namespace paddle_mobile {
namespace framework {
namespace proto {
class BlockDesc;
class BlockDescDefaultTypeInternal;
extern BlockDescDefaultTypeInternal _BlockDesc_default_instance_;
class OpDesc;
class OpDescDefaultTypeInternal;
extern OpDescDefaultTypeInternal _OpDesc_default_instance_;
class OpDesc_Attr;
class OpDesc_AttrDefaultTypeInternal;
extern OpDesc_AttrDefaultTypeInternal _OpDesc_Attr_default_instance_;
class OpDesc_Var;
class OpDesc_VarDefaultTypeInternal;
extern OpDesc_VarDefaultTypeInternal _OpDesc_Var_default_instance_;
class OpProto;
class OpProtoDefaultTypeInternal;
extern OpProtoDefaultTypeInternal _OpProto_default_instance_;
class OpProto_Attr;
class OpProto_AttrDefaultTypeInternal;
extern OpProto_AttrDefaultTypeInternal _OpProto_Attr_default_instance_;
class OpProto_Var;
class OpProto_VarDefaultTypeInternal;
extern OpProto_VarDefaultTypeInternal _OpProto_Var_default_instance_;
class ProgramDesc;
class ProgramDescDefaultTypeInternal;
extern ProgramDescDefaultTypeInternal _ProgramDesc_default_instance_;
class VarDesc;
class VarDescDefaultTypeInternal;
extern VarDescDefaultTypeInternal _VarDesc_default_instance_;
class VarType;
class VarTypeDefaultTypeInternal;
extern VarTypeDefaultTypeInternal _VarType_default_instance_;
class VarType_ChannelDesc;
class VarType_ChannelDescDefaultTypeInternal;
extern VarType_ChannelDescDefaultTypeInternal _VarType_ChannelDesc_default_instance_;
class VarType_LoDTensorArrayDesc;
class VarType_LoDTensorArrayDescDefaultTypeInternal;
extern VarType_LoDTensorArrayDescDefaultTypeInternal _VarType_LoDTensorArrayDesc_default_instance_;
class VarType_LoDTensorDesc;
class VarType_LoDTensorDescDefaultTypeInternal;
extern VarType_LoDTensorDescDefaultTypeInternal _VarType_LoDTensorDesc_default_instance_;
class VarType_ReaderDesc;
class VarType_ReaderDescDefaultTypeInternal;
extern VarType_ReaderDescDefaultTypeInternal _VarType_ReaderDesc_default_instance_;
class VarType_TensorDesc;
class VarType_TensorDescDefaultTypeInternal;
extern VarType_TensorDescDefaultTypeInternal _VarType_TensorDesc_default_instance_;
class VarType_Tuple;
class VarType_TupleDefaultTypeInternal;
extern VarType_TupleDefaultTypeInternal _VarType_Tuple_default_instance_;
}  // namespace proto
}  // namespace framework
}  // namespace paddle_mobile

namespace paddle_mobile {
namespace framework {
namespace proto {

namespace protobuf_framework_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_framework_2eproto

enum VarType_Type {
  VarType_Type_BOOL = 0,
  VarType_Type_INT16 = 1,
  VarType_Type_INT32 = 2,
  VarType_Type_INT64 = 3,
  VarType_Type_FP16 = 4,
  VarType_Type_FP32 = 5,
  VarType_Type_FP64 = 6,
  VarType_Type_LOD_TENSOR = 7,
  VarType_Type_SELECTED_ROWS = 8,
  VarType_Type_FEED_MINIBATCH = 9,
  VarType_Type_FETCH_LIST = 10,
  VarType_Type_STEP_SCOPES = 11,
  VarType_Type_LOD_RANK_TABLE = 12,
  VarType_Type_LOD_TENSOR_ARRAY = 13,
  VarType_Type_PLACE_LIST = 14,
  VarType_Type_READER = 15,
  VarType_Type_CHANNEL = 16,
  VarType_Type_RAW = 17,
  VarType_Type_TUPLE = 18
};
bool VarType_Type_IsValid(int value);
const VarType_Type VarType_Type_Type_MIN = VarType_Type_BOOL;
const VarType_Type VarType_Type_Type_MAX = VarType_Type_TUPLE;
const int VarType_Type_Type_ARRAYSIZE = VarType_Type_Type_MAX + 1;

enum AttrType {
  INT = 0,
  FLOAT = 1,
  STRING = 2,
  INTS = 3,
  FLOATS = 4,
  STRINGS = 5,
  BOOLEAN = 6,
  BOOLEANS = 7,
  BLOCK = 8,
  LONG = 9
};
bool AttrType_IsValid(int value);
const AttrType AttrType_MIN = INT;
const AttrType AttrType_MAX = LONG;
const int AttrType_ARRAYSIZE = AttrType_MAX + 1;

// ===================================================================

class OpDesc_Attr : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.OpDesc.Attr) */ {
 public:
  OpDesc_Attr();
  virtual ~OpDesc_Attr();

  OpDesc_Attr(const OpDesc_Attr& from);

  inline OpDesc_Attr& operator=(const OpDesc_Attr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpDesc_Attr(OpDesc_Attr&& from) noexcept
    : OpDesc_Attr() {
    *this = ::std::move(from);
  }

  inline OpDesc_Attr& operator=(OpDesc_Attr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OpDesc_Attr& default_instance();

  static inline const OpDesc_Attr* internal_default_instance() {
    return reinterpret_cast<const OpDesc_Attr*>(
               &_OpDesc_Attr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(OpDesc_Attr* other);
  friend void swap(OpDesc_Attr& a, OpDesc_Attr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpDesc_Attr* New() const PROTOBUF_FINAL { return New(NULL); }

  OpDesc_Attr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpDesc_Attr& from);
  void MergeFrom(const OpDesc_Attr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpDesc_Attr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 ints = 6;
  int ints_size() const;
  void clear_ints();
  static const int kIntsFieldNumber = 6;
  ::google::protobuf::int32 ints(int index) const;
  void set_ints(int index, ::google::protobuf::int32 value);
  void add_ints(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ints() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ints();

  // repeated float floats = 7;
  int floats_size() const;
  void clear_floats();
  static const int kFloatsFieldNumber = 7;
  float floats(int index) const;
  void set_floats(int index, float value);
  void add_floats(float value);
  const ::google::protobuf::RepeatedField< float >&
      floats() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_floats();

  // repeated string strings = 8;
  int strings_size() const;
  void clear_strings();
  static const int kStringsFieldNumber = 8;
  const ::std::string& strings(int index) const;
  ::std::string* mutable_strings(int index);
  void set_strings(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_strings(int index, ::std::string&& value);
  #endif
  void set_strings(int index, const char* value);
  void set_strings(int index, const char* value, size_t size);
  ::std::string* add_strings();
  void add_strings(const ::std::string& value);
  #if LANG_CXX11
  void add_strings(::std::string&& value);
  #endif
  void add_strings(const char* value);
  void add_strings(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& strings() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_strings();

  // repeated bool bools = 11;
  int bools_size() const;
  void clear_bools();
  static const int kBoolsFieldNumber = 11;
  bool bools(int index) const;
  void set_bools(int index, bool value);
  void add_bools(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      bools() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_bools();

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string s = 5;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 5;
  const ::std::string& s() const;
  void set_s(const ::std::string& value);
  #if LANG_CXX11
  void set_s(::std::string&& value);
  #endif
  void set_s(const char* value);
  void set_s(const char* value, size_t size);
  ::std::string* mutable_s();
  ::std::string* release_s();
  void set_allocated_s(::std::string* s);

  // required .paddle_mobile.framework.proto.AttrType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::paddle_mobile::framework::proto::AttrType type() const;
  void set_type(::paddle_mobile::framework::proto::AttrType value);

  // optional int32 i = 3;
  bool has_i() const;
  void clear_i();
  static const int kIFieldNumber = 3;
  ::google::protobuf::int32 i() const;
  void set_i(::google::protobuf::int32 value);

  // optional float f = 4;
  bool has_f() const;
  void clear_f();
  static const int kFFieldNumber = 4;
  float f() const;
  void set_f(float value);

  // optional bool b = 10;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 10;
  bool b() const;
  void set_b(bool value);

  // optional int64 l = 13;
  bool has_l() const;
  void clear_l();
  static const int kLFieldNumber = 13;
  ::google::protobuf::int64 l() const;
  void set_l(::google::protobuf::int64 value);

  // optional int32 block_idx = 12;
  bool has_block_idx() const;
  void clear_block_idx();
  static const int kBlockIdxFieldNumber = 12;
  ::google::protobuf::int32 block_idx() const;
  void set_block_idx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.OpDesc.Attr)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_i();
  void clear_has_i();
  void set_has_f();
  void clear_has_f();
  void set_has_s();
  void clear_has_s();
  void set_has_b();
  void clear_has_b();
  void set_has_block_idx();
  void clear_has_block_idx();
  void set_has_l();
  void clear_has_l();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ints_;
  ::google::protobuf::RepeatedField< float > floats_;
  ::google::protobuf::RepeatedPtrField< ::std::string> strings_;
  ::google::protobuf::RepeatedField< bool > bools_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr s_;
  int type_;
  ::google::protobuf::int32 i_;
  float f_;
  bool b_;
  ::google::protobuf::int64 l_;
  ::google::protobuf::int32 block_idx_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpDesc_Var : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.OpDesc.Var) */ {
 public:
  OpDesc_Var();
  virtual ~OpDesc_Var();

  OpDesc_Var(const OpDesc_Var& from);

  inline OpDesc_Var& operator=(const OpDesc_Var& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpDesc_Var(OpDesc_Var&& from) noexcept
    : OpDesc_Var() {
    *this = ::std::move(from);
  }

  inline OpDesc_Var& operator=(OpDesc_Var&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OpDesc_Var& default_instance();

  static inline const OpDesc_Var* internal_default_instance() {
    return reinterpret_cast<const OpDesc_Var*>(
               &_OpDesc_Var_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(OpDesc_Var* other);
  friend void swap(OpDesc_Var& a, OpDesc_Var& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpDesc_Var* New() const PROTOBUF_FINAL { return New(NULL); }

  OpDesc_Var* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpDesc_Var& from);
  void MergeFrom(const OpDesc_Var& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpDesc_Var* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string arguments = 2;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 2;
  const ::std::string& arguments(int index) const;
  ::std::string* mutable_arguments(int index);
  void set_arguments(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_arguments(int index, ::std::string&& value);
  #endif
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const char* value, size_t size);
  ::std::string* add_arguments();
  void add_arguments(const ::std::string& value);
  #if LANG_CXX11
  void add_arguments(::std::string&& value);
  #endif
  void add_arguments(const char* value);
  void add_arguments(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_arguments();

  // required string parameter = 1;
  bool has_parameter() const;
  void clear_parameter();
  static const int kParameterFieldNumber = 1;
  const ::std::string& parameter() const;
  void set_parameter(const ::std::string& value);
  #if LANG_CXX11
  void set_parameter(::std::string&& value);
  #endif
  void set_parameter(const char* value);
  void set_parameter(const char* value, size_t size);
  ::std::string* mutable_parameter();
  ::std::string* release_parameter();
  void set_allocated_parameter(::std::string* parameter);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.OpDesc.Var)
 private:
  void set_has_parameter();
  void clear_has_parameter();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> arguments_;
  ::google::protobuf::internal::ArenaStringPtr parameter_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpDesc : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.OpDesc) */ {
 public:
  OpDesc();
  virtual ~OpDesc();

  OpDesc(const OpDesc& from);

  inline OpDesc& operator=(const OpDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpDesc(OpDesc&& from) noexcept
    : OpDesc() {
    *this = ::std::move(from);
  }

  inline OpDesc& operator=(OpDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OpDesc& default_instance();

  static inline const OpDesc* internal_default_instance() {
    return reinterpret_cast<const OpDesc*>(
               &_OpDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(OpDesc* other);
  friend void swap(OpDesc& a, OpDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  OpDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpDesc& from);
  void MergeFrom(const OpDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef OpDesc_Attr Attr;
  typedef OpDesc_Var Var;

  // accessors -------------------------------------------------------

  // repeated .paddle_mobile.framework.proto.OpDesc.Var inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  const ::paddle_mobile::framework::proto::OpDesc_Var& inputs(int index) const;
  ::paddle_mobile::framework::proto::OpDesc_Var* mutable_inputs(int index);
  ::paddle_mobile::framework::proto::OpDesc_Var* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Var >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Var >&
      inputs() const;

  // repeated .paddle_mobile.framework.proto.OpDesc.Var outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  const ::paddle_mobile::framework::proto::OpDesc_Var& outputs(int index) const;
  ::paddle_mobile::framework::proto::OpDesc_Var* mutable_outputs(int index);
  ::paddle_mobile::framework::proto::OpDesc_Var* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Var >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Var >&
      outputs() const;

  // repeated .paddle_mobile.framework.proto.OpDesc.Attr attrs = 4;
  int attrs_size() const;
  void clear_attrs();
  static const int kAttrsFieldNumber = 4;
  const ::paddle_mobile::framework::proto::OpDesc_Attr& attrs(int index) const;
  ::paddle_mobile::framework::proto::OpDesc_Attr* mutable_attrs(int index);
  ::paddle_mobile::framework::proto::OpDesc_Attr* add_attrs();
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Attr >*
      mutable_attrs();
  const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Attr >&
      attrs() const;

  // required string type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional bool is_target = 5 [default = false];
  bool has_is_target() const;
  void clear_is_target();
  static const int kIsTargetFieldNumber = 5;
  bool is_target() const;
  void set_is_target(bool value);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.OpDesc)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_is_target();
  void clear_has_is_target();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Var > inputs_;
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Var > outputs_;
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Attr > attrs_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  bool is_target_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpProto_Var : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.OpProto.Var) */ {
 public:
  OpProto_Var();
  virtual ~OpProto_Var();

  OpProto_Var(const OpProto_Var& from);

  inline OpProto_Var& operator=(const OpProto_Var& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpProto_Var(OpProto_Var&& from) noexcept
    : OpProto_Var() {
    *this = ::std::move(from);
  }

  inline OpProto_Var& operator=(OpProto_Var&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OpProto_Var& default_instance();

  static inline const OpProto_Var* internal_default_instance() {
    return reinterpret_cast<const OpProto_Var*>(
               &_OpProto_Var_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(OpProto_Var* other);
  friend void swap(OpProto_Var& a, OpProto_Var& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpProto_Var* New() const PROTOBUF_FINAL { return New(NULL); }

  OpProto_Var* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpProto_Var& from);
  void MergeFrom(const OpProto_Var& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpProto_Var* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string comment = 2;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional bool duplicable = 3 [default = false];
  bool has_duplicable() const;
  void clear_duplicable();
  static const int kDuplicableFieldNumber = 3;
  bool duplicable() const;
  void set_duplicable(bool value);

  // optional bool intermediate = 4 [default = false];
  bool has_intermediate() const;
  void clear_intermediate();
  static const int kIntermediateFieldNumber = 4;
  bool intermediate() const;
  void set_intermediate(bool value);

  // optional bool dispensable = 5 [default = false];
  bool has_dispensable() const;
  void clear_dispensable();
  static const int kDispensableFieldNumber = 5;
  bool dispensable() const;
  void set_dispensable(bool value);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.OpProto.Var)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_comment();
  void clear_has_comment();
  void set_has_duplicable();
  void clear_has_duplicable();
  void set_has_intermediate();
  void clear_has_intermediate();
  void set_has_dispensable();
  void clear_has_dispensable();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  bool duplicable_;
  bool intermediate_;
  bool dispensable_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpProto_Attr : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.OpProto.Attr) */ {
 public:
  OpProto_Attr();
  virtual ~OpProto_Attr();

  OpProto_Attr(const OpProto_Attr& from);

  inline OpProto_Attr& operator=(const OpProto_Attr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpProto_Attr(OpProto_Attr&& from) noexcept
    : OpProto_Attr() {
    *this = ::std::move(from);
  }

  inline OpProto_Attr& operator=(OpProto_Attr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OpProto_Attr& default_instance();

  static inline const OpProto_Attr* internal_default_instance() {
    return reinterpret_cast<const OpProto_Attr*>(
               &_OpProto_Attr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(OpProto_Attr* other);
  friend void swap(OpProto_Attr& a, OpProto_Attr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpProto_Attr* New() const PROTOBUF_FINAL { return New(NULL); }

  OpProto_Attr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpProto_Attr& from);
  void MergeFrom(const OpProto_Attr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpProto_Attr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string comment = 3;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 3;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // required .paddle_mobile.framework.proto.AttrType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::paddle_mobile::framework::proto::AttrType type() const;
  void set_type(::paddle_mobile::framework::proto::AttrType value);

  // optional bool generated = 4 [default = false];
  bool has_generated() const;
  void clear_generated();
  static const int kGeneratedFieldNumber = 4;
  bool generated() const;
  void set_generated(bool value);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.OpProto.Attr)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_comment();
  void clear_has_comment();
  void set_has_generated();
  void clear_has_generated();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  int type_;
  bool generated_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpProto : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.OpProto) */ {
 public:
  OpProto();
  virtual ~OpProto();

  OpProto(const OpProto& from);

  inline OpProto& operator=(const OpProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpProto(OpProto&& from) noexcept
    : OpProto() {
    *this = ::std::move(from);
  }

  inline OpProto& operator=(OpProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OpProto& default_instance();

  static inline const OpProto* internal_default_instance() {
    return reinterpret_cast<const OpProto*>(
               &_OpProto_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(OpProto* other);
  friend void swap(OpProto& a, OpProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpProto* New() const PROTOBUF_FINAL { return New(NULL); }

  OpProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpProto& from);
  void MergeFrom(const OpProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef OpProto_Var Var;
  typedef OpProto_Attr Attr;

  // accessors -------------------------------------------------------

  // repeated .paddle_mobile.framework.proto.OpProto.Var inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  const ::paddle_mobile::framework::proto::OpProto_Var& inputs(int index) const;
  ::paddle_mobile::framework::proto::OpProto_Var* mutable_inputs(int index);
  ::paddle_mobile::framework::proto::OpProto_Var* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Var >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Var >&
      inputs() const;

  // repeated .paddle_mobile.framework.proto.OpProto.Var outputs = 3;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 3;
  const ::paddle_mobile::framework::proto::OpProto_Var& outputs(int index) const;
  ::paddle_mobile::framework::proto::OpProto_Var* mutable_outputs(int index);
  ::paddle_mobile::framework::proto::OpProto_Var* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Var >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Var >&
      outputs() const;

  // repeated .paddle_mobile.framework.proto.OpProto.Attr attrs = 4;
  int attrs_size() const;
  void clear_attrs();
  static const int kAttrsFieldNumber = 4;
  const ::paddle_mobile::framework::proto::OpProto_Attr& attrs(int index) const;
  ::paddle_mobile::framework::proto::OpProto_Attr* mutable_attrs(int index);
  ::paddle_mobile::framework::proto::OpProto_Attr* add_attrs();
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Attr >*
      mutable_attrs();
  const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Attr >&
      attrs() const;

  // required string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // required string comment = 5;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 5;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.OpProto)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_comment();
  void clear_has_comment();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Var > inputs_;
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Var > outputs_;
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Attr > attrs_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarType_TensorDesc : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.VarType.TensorDesc) */ {
 public:
  VarType_TensorDesc();
  virtual ~VarType_TensorDesc();

  VarType_TensorDesc(const VarType_TensorDesc& from);

  inline VarType_TensorDesc& operator=(const VarType_TensorDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarType_TensorDesc(VarType_TensorDesc&& from) noexcept
    : VarType_TensorDesc() {
    *this = ::std::move(from);
  }

  inline VarType_TensorDesc& operator=(VarType_TensorDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VarType_TensorDesc& default_instance();

  static inline const VarType_TensorDesc* internal_default_instance() {
    return reinterpret_cast<const VarType_TensorDesc*>(
               &_VarType_TensorDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(VarType_TensorDesc* other);
  friend void swap(VarType_TensorDesc& a, VarType_TensorDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarType_TensorDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  VarType_TensorDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VarType_TensorDesc& from);
  void MergeFrom(const VarType_TensorDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VarType_TensorDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 dims = 2;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 2;
  ::google::protobuf::int64 dims(int index) const;
  void set_dims(int index, ::google::protobuf::int64 value);
  void add_dims(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_dims();

  // required .paddle_mobile.framework.proto.VarType.Type data_type = 1;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 1;
  ::paddle_mobile::framework::proto::VarType_Type data_type() const;
  void set_data_type(::paddle_mobile::framework::proto::VarType_Type value);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.VarType.TensorDesc)
 private:
  void set_has_data_type();
  void clear_has_data_type();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > dims_;
  int data_type_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarType_LoDTensorDesc : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.VarType.LoDTensorDesc) */ {
 public:
  VarType_LoDTensorDesc();
  virtual ~VarType_LoDTensorDesc();

  VarType_LoDTensorDesc(const VarType_LoDTensorDesc& from);

  inline VarType_LoDTensorDesc& operator=(const VarType_LoDTensorDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarType_LoDTensorDesc(VarType_LoDTensorDesc&& from) noexcept
    : VarType_LoDTensorDesc() {
    *this = ::std::move(from);
  }

  inline VarType_LoDTensorDesc& operator=(VarType_LoDTensorDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VarType_LoDTensorDesc& default_instance();

  static inline const VarType_LoDTensorDesc* internal_default_instance() {
    return reinterpret_cast<const VarType_LoDTensorDesc*>(
               &_VarType_LoDTensorDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(VarType_LoDTensorDesc* other);
  friend void swap(VarType_LoDTensorDesc& a, VarType_LoDTensorDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarType_LoDTensorDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  VarType_LoDTensorDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VarType_LoDTensorDesc& from);
  void MergeFrom(const VarType_LoDTensorDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VarType_LoDTensorDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .paddle_mobile.framework.proto.VarType.TensorDesc tensor = 1;
  bool has_tensor() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 1;
  const ::paddle_mobile::framework::proto::VarType_TensorDesc& tensor() const;
  ::paddle_mobile::framework::proto::VarType_TensorDesc* mutable_tensor();
  ::paddle_mobile::framework::proto::VarType_TensorDesc* release_tensor();
  void set_allocated_tensor(::paddle_mobile::framework::proto::VarType_TensorDesc* tensor);

  // optional int32 lod_level = 2 [default = 0];
  bool has_lod_level() const;
  void clear_lod_level();
  static const int kLodLevelFieldNumber = 2;
  ::google::protobuf::int32 lod_level() const;
  void set_lod_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.VarType.LoDTensorDesc)
 private:
  void set_has_tensor();
  void clear_has_tensor();
  void set_has_lod_level();
  void clear_has_lod_level();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::paddle_mobile::framework::proto::VarType_TensorDesc* tensor_;
  ::google::protobuf::int32 lod_level_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarType_LoDTensorArrayDesc : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.VarType.LoDTensorArrayDesc) */ {
 public:
  VarType_LoDTensorArrayDesc();
  virtual ~VarType_LoDTensorArrayDesc();

  VarType_LoDTensorArrayDesc(const VarType_LoDTensorArrayDesc& from);

  inline VarType_LoDTensorArrayDesc& operator=(const VarType_LoDTensorArrayDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarType_LoDTensorArrayDesc(VarType_LoDTensorArrayDesc&& from) noexcept
    : VarType_LoDTensorArrayDesc() {
    *this = ::std::move(from);
  }

  inline VarType_LoDTensorArrayDesc& operator=(VarType_LoDTensorArrayDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VarType_LoDTensorArrayDesc& default_instance();

  static inline const VarType_LoDTensorArrayDesc* internal_default_instance() {
    return reinterpret_cast<const VarType_LoDTensorArrayDesc*>(
               &_VarType_LoDTensorArrayDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(VarType_LoDTensorArrayDesc* other);
  friend void swap(VarType_LoDTensorArrayDesc& a, VarType_LoDTensorArrayDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarType_LoDTensorArrayDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  VarType_LoDTensorArrayDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VarType_LoDTensorArrayDesc& from);
  void MergeFrom(const VarType_LoDTensorArrayDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VarType_LoDTensorArrayDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .paddle_mobile.framework.proto.VarType.TensorDesc tensor = 1;
  bool has_tensor() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 1;
  const ::paddle_mobile::framework::proto::VarType_TensorDesc& tensor() const;
  ::paddle_mobile::framework::proto::VarType_TensorDesc* mutable_tensor();
  ::paddle_mobile::framework::proto::VarType_TensorDesc* release_tensor();
  void set_allocated_tensor(::paddle_mobile::framework::proto::VarType_TensorDesc* tensor);

  // optional int32 lod_level = 2 [default = 0];
  bool has_lod_level() const;
  void clear_lod_level();
  static const int kLodLevelFieldNumber = 2;
  ::google::protobuf::int32 lod_level() const;
  void set_lod_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.VarType.LoDTensorArrayDesc)
 private:
  void set_has_tensor();
  void clear_has_tensor();
  void set_has_lod_level();
  void clear_has_lod_level();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::paddle_mobile::framework::proto::VarType_TensorDesc* tensor_;
  ::google::protobuf::int32 lod_level_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarType_ReaderDesc : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.VarType.ReaderDesc) */ {
 public:
  VarType_ReaderDesc();
  virtual ~VarType_ReaderDesc();

  VarType_ReaderDesc(const VarType_ReaderDesc& from);

  inline VarType_ReaderDesc& operator=(const VarType_ReaderDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarType_ReaderDesc(VarType_ReaderDesc&& from) noexcept
    : VarType_ReaderDesc() {
    *this = ::std::move(from);
  }

  inline VarType_ReaderDesc& operator=(VarType_ReaderDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VarType_ReaderDesc& default_instance();

  static inline const VarType_ReaderDesc* internal_default_instance() {
    return reinterpret_cast<const VarType_ReaderDesc*>(
               &_VarType_ReaderDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(VarType_ReaderDesc* other);
  friend void swap(VarType_ReaderDesc& a, VarType_ReaderDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarType_ReaderDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  VarType_ReaderDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VarType_ReaderDesc& from);
  void MergeFrom(const VarType_ReaderDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VarType_ReaderDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .paddle_mobile.framework.proto.VarType.LoDTensorDesc lod_tensor = 1;
  int lod_tensor_size() const;
  void clear_lod_tensor();
  static const int kLodTensorFieldNumber = 1;
  const ::paddle_mobile::framework::proto::VarType_LoDTensorDesc& lod_tensor(int index) const;
  ::paddle_mobile::framework::proto::VarType_LoDTensorDesc* mutable_lod_tensor(int index);
  ::paddle_mobile::framework::proto::VarType_LoDTensorDesc* add_lod_tensor();
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::VarType_LoDTensorDesc >*
      mutable_lod_tensor();
  const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::VarType_LoDTensorDesc >&
      lod_tensor() const;

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.VarType.ReaderDesc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::VarType_LoDTensorDesc > lod_tensor_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarType_ChannelDesc : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.VarType.ChannelDesc) */ {
 public:
  VarType_ChannelDesc();
  virtual ~VarType_ChannelDesc();

  VarType_ChannelDesc(const VarType_ChannelDesc& from);

  inline VarType_ChannelDesc& operator=(const VarType_ChannelDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarType_ChannelDesc(VarType_ChannelDesc&& from) noexcept
    : VarType_ChannelDesc() {
    *this = ::std::move(from);
  }

  inline VarType_ChannelDesc& operator=(VarType_ChannelDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VarType_ChannelDesc& default_instance();

  static inline const VarType_ChannelDesc* internal_default_instance() {
    return reinterpret_cast<const VarType_ChannelDesc*>(
               &_VarType_ChannelDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(VarType_ChannelDesc* other);
  friend void swap(VarType_ChannelDesc& a, VarType_ChannelDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarType_ChannelDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  VarType_ChannelDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VarType_ChannelDesc& from);
  void MergeFrom(const VarType_ChannelDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VarType_ChannelDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 capacity = 2;
  bool has_capacity() const;
  void clear_capacity();
  static const int kCapacityFieldNumber = 2;
  ::google::protobuf::int64 capacity() const;
  void set_capacity(::google::protobuf::int64 value);

  // required .paddle_mobile.framework.proto.VarType.Type data_type = 1;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 1;
  ::paddle_mobile::framework::proto::VarType_Type data_type() const;
  void set_data_type(::paddle_mobile::framework::proto::VarType_Type value);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.VarType.ChannelDesc)
 private:
  void set_has_data_type();
  void clear_has_data_type();
  void set_has_capacity();
  void clear_has_capacity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 capacity_;
  int data_type_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarType_Tuple : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.VarType.Tuple) */ {
 public:
  VarType_Tuple();
  virtual ~VarType_Tuple();

  VarType_Tuple(const VarType_Tuple& from);

  inline VarType_Tuple& operator=(const VarType_Tuple& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarType_Tuple(VarType_Tuple&& from) noexcept
    : VarType_Tuple() {
    *this = ::std::move(from);
  }

  inline VarType_Tuple& operator=(VarType_Tuple&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VarType_Tuple& default_instance();

  static inline const VarType_Tuple* internal_default_instance() {
    return reinterpret_cast<const VarType_Tuple*>(
               &_VarType_Tuple_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(VarType_Tuple* other);
  friend void swap(VarType_Tuple& a, VarType_Tuple& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarType_Tuple* New() const PROTOBUF_FINAL { return New(NULL); }

  VarType_Tuple* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VarType_Tuple& from);
  void MergeFrom(const VarType_Tuple& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VarType_Tuple* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .paddle_mobile.framework.proto.VarType.Type element_type = 1;
  int element_type_size() const;
  void clear_element_type();
  static const int kElementTypeFieldNumber = 1;
  ::paddle_mobile::framework::proto::VarType_Type element_type(int index) const;
  void set_element_type(int index, ::paddle_mobile::framework::proto::VarType_Type value);
  void add_element_type(::paddle_mobile::framework::proto::VarType_Type value);
  const ::google::protobuf::RepeatedField<int>& element_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_element_type();

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.VarType.Tuple)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> element_type_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.VarType) */ {
 public:
  VarType();
  virtual ~VarType();

  VarType(const VarType& from);

  inline VarType& operator=(const VarType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarType(VarType&& from) noexcept
    : VarType() {
    *this = ::std::move(from);
  }

  inline VarType& operator=(VarType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VarType& default_instance();

  static inline const VarType* internal_default_instance() {
    return reinterpret_cast<const VarType*>(
               &_VarType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(VarType* other);
  friend void swap(VarType& a, VarType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarType* New() const PROTOBUF_FINAL { return New(NULL); }

  VarType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VarType& from);
  void MergeFrom(const VarType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VarType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VarType_TensorDesc TensorDesc;
  typedef VarType_LoDTensorDesc LoDTensorDesc;
  typedef VarType_LoDTensorArrayDesc LoDTensorArrayDesc;
  typedef VarType_ReaderDesc ReaderDesc;
  typedef VarType_ChannelDesc ChannelDesc;
  typedef VarType_Tuple Tuple;

  typedef VarType_Type Type;
  static const Type BOOL =
    VarType_Type_BOOL;
  static const Type INT16 =
    VarType_Type_INT16;
  static const Type INT32 =
    VarType_Type_INT32;
  static const Type INT64 =
    VarType_Type_INT64;
  static const Type FP16 =
    VarType_Type_FP16;
  static const Type FP32 =
    VarType_Type_FP32;
  static const Type FP64 =
    VarType_Type_FP64;
  static const Type LOD_TENSOR =
    VarType_Type_LOD_TENSOR;
  static const Type SELECTED_ROWS =
    VarType_Type_SELECTED_ROWS;
  static const Type FEED_MINIBATCH =
    VarType_Type_FEED_MINIBATCH;
  static const Type FETCH_LIST =
    VarType_Type_FETCH_LIST;
  static const Type STEP_SCOPES =
    VarType_Type_STEP_SCOPES;
  static const Type LOD_RANK_TABLE =
    VarType_Type_LOD_RANK_TABLE;
  static const Type LOD_TENSOR_ARRAY =
    VarType_Type_LOD_TENSOR_ARRAY;
  static const Type PLACE_LIST =
    VarType_Type_PLACE_LIST;
  static const Type READER =
    VarType_Type_READER;
  static const Type CHANNEL =
    VarType_Type_CHANNEL;
  static const Type RAW =
    VarType_Type_RAW;
  static const Type TUPLE =
    VarType_Type_TUPLE;
  static inline bool Type_IsValid(int value) {
    return VarType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    VarType_Type_Type_MIN;
  static const Type Type_MAX =
    VarType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    VarType_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .paddle_mobile.framework.proto.VarType.TensorDesc selected_rows = 2;
  bool has_selected_rows() const;
  void clear_selected_rows();
  static const int kSelectedRowsFieldNumber = 2;
  const ::paddle_mobile::framework::proto::VarType_TensorDesc& selected_rows() const;
  ::paddle_mobile::framework::proto::VarType_TensorDesc* mutable_selected_rows();
  ::paddle_mobile::framework::proto::VarType_TensorDesc* release_selected_rows();
  void set_allocated_selected_rows(::paddle_mobile::framework::proto::VarType_TensorDesc* selected_rows);

  // optional .paddle_mobile.framework.proto.VarType.LoDTensorDesc lod_tensor = 3;
  bool has_lod_tensor() const;
  void clear_lod_tensor();
  static const int kLodTensorFieldNumber = 3;
  const ::paddle_mobile::framework::proto::VarType_LoDTensorDesc& lod_tensor() const;
  ::paddle_mobile::framework::proto::VarType_LoDTensorDesc* mutable_lod_tensor();
  ::paddle_mobile::framework::proto::VarType_LoDTensorDesc* release_lod_tensor();
  void set_allocated_lod_tensor(::paddle_mobile::framework::proto::VarType_LoDTensorDesc* lod_tensor);

  // optional .paddle_mobile.framework.proto.VarType.LoDTensorArrayDesc tensor_array = 4;
  bool has_tensor_array() const;
  void clear_tensor_array();
  static const int kTensorArrayFieldNumber = 4;
  const ::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc& tensor_array() const;
  ::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc* mutable_tensor_array();
  ::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc* release_tensor_array();
  void set_allocated_tensor_array(::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc* tensor_array);

  // optional .paddle_mobile.framework.proto.VarType.ReaderDesc reader = 5;
  bool has_reader() const;
  void clear_reader();
  static const int kReaderFieldNumber = 5;
  const ::paddle_mobile::framework::proto::VarType_ReaderDesc& reader() const;
  ::paddle_mobile::framework::proto::VarType_ReaderDesc* mutable_reader();
  ::paddle_mobile::framework::proto::VarType_ReaderDesc* release_reader();
  void set_allocated_reader(::paddle_mobile::framework::proto::VarType_ReaderDesc* reader);

  // optional .paddle_mobile.framework.proto.VarType.ChannelDesc channel = 6;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 6;
  const ::paddle_mobile::framework::proto::VarType_ChannelDesc& channel() const;
  ::paddle_mobile::framework::proto::VarType_ChannelDesc* mutable_channel();
  ::paddle_mobile::framework::proto::VarType_ChannelDesc* release_channel();
  void set_allocated_channel(::paddle_mobile::framework::proto::VarType_ChannelDesc* channel);

  // optional .paddle_mobile.framework.proto.VarType.Tuple tuple = 7;
  bool has_tuple() const;
  void clear_tuple();
  static const int kTupleFieldNumber = 7;
  const ::paddle_mobile::framework::proto::VarType_Tuple& tuple() const;
  ::paddle_mobile::framework::proto::VarType_Tuple* mutable_tuple();
  ::paddle_mobile::framework::proto::VarType_Tuple* release_tuple();
  void set_allocated_tuple(::paddle_mobile::framework::proto::VarType_Tuple* tuple);

  // required .paddle_mobile.framework.proto.VarType.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::paddle_mobile::framework::proto::VarType_Type type() const;
  void set_type(::paddle_mobile::framework::proto::VarType_Type value);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.VarType)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_selected_rows();
  void clear_has_selected_rows();
  void set_has_lod_tensor();
  void clear_has_lod_tensor();
  void set_has_tensor_array();
  void clear_has_tensor_array();
  void set_has_reader();
  void clear_has_reader();
  void set_has_channel();
  void clear_has_channel();
  void set_has_tuple();
  void clear_has_tuple();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::paddle_mobile::framework::proto::VarType_TensorDesc* selected_rows_;
  ::paddle_mobile::framework::proto::VarType_LoDTensorDesc* lod_tensor_;
  ::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc* tensor_array_;
  ::paddle_mobile::framework::proto::VarType_ReaderDesc* reader_;
  ::paddle_mobile::framework::proto::VarType_ChannelDesc* channel_;
  ::paddle_mobile::framework::proto::VarType_Tuple* tuple_;
  int type_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarDesc : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.VarDesc) */ {
 public:
  VarDesc();
  virtual ~VarDesc();

  VarDesc(const VarDesc& from);

  inline VarDesc& operator=(const VarDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarDesc(VarDesc&& from) noexcept
    : VarDesc() {
    *this = ::std::move(from);
  }

  inline VarDesc& operator=(VarDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VarDesc& default_instance();

  static inline const VarDesc* internal_default_instance() {
    return reinterpret_cast<const VarDesc*>(
               &_VarDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(VarDesc* other);
  friend void swap(VarDesc& a, VarDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  VarDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VarDesc& from);
  void MergeFrom(const VarDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VarDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .paddle_mobile.framework.proto.VarType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::paddle_mobile::framework::proto::VarType& type() const;
  ::paddle_mobile::framework::proto::VarType* mutable_type();
  ::paddle_mobile::framework::proto::VarType* release_type();
  void set_allocated_type(::paddle_mobile::framework::proto::VarType* type);

  // optional bool persistable = 3 [default = false];
  bool has_persistable() const;
  void clear_persistable();
  static const int kPersistableFieldNumber = 3;
  bool persistable() const;
  void set_persistable(bool value);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.VarDesc)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_persistable();
  void clear_has_persistable();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::paddle_mobile::framework::proto::VarType* type_;
  bool persistable_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockDesc : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.BlockDesc) */ {
 public:
  BlockDesc();
  virtual ~BlockDesc();

  BlockDesc(const BlockDesc& from);

  inline BlockDesc& operator=(const BlockDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockDesc(BlockDesc&& from) noexcept
    : BlockDesc() {
    *this = ::std::move(from);
  }

  inline BlockDesc& operator=(BlockDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BlockDesc& default_instance();

  static inline const BlockDesc* internal_default_instance() {
    return reinterpret_cast<const BlockDesc*>(
               &_BlockDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(BlockDesc* other);
  friend void swap(BlockDesc& a, BlockDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const BlockDesc& from);
  void MergeFrom(const BlockDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .paddle_mobile.framework.proto.VarDesc vars = 3;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 3;
  const ::paddle_mobile::framework::proto::VarDesc& vars(int index) const;
  ::paddle_mobile::framework::proto::VarDesc* mutable_vars(int index);
  ::paddle_mobile::framework::proto::VarDesc* add_vars();
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::VarDesc >*
      mutable_vars();
  const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::VarDesc >&
      vars() const;

  // repeated .paddle_mobile.framework.proto.OpDesc ops = 4;
  int ops_size() const;
  void clear_ops();
  static const int kOpsFieldNumber = 4;
  const ::paddle_mobile::framework::proto::OpDesc& ops(int index) const;
  ::paddle_mobile::framework::proto::OpDesc* mutable_ops(int index);
  ::paddle_mobile::framework::proto::OpDesc* add_ops();
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc >*
      mutable_ops();
  const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc >&
      ops() const;

  // required int32 idx = 1;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 1;
  ::google::protobuf::int32 idx() const;
  void set_idx(::google::protobuf::int32 value);

  // required int32 parent_idx = 2;
  bool has_parent_idx() const;
  void clear_parent_idx();
  static const int kParentIdxFieldNumber = 2;
  ::google::protobuf::int32 parent_idx() const;
  void set_parent_idx(::google::protobuf::int32 value);

  // optional int32 forward_block_idx = 5 [default = -1];
  bool has_forward_block_idx() const;
  void clear_forward_block_idx();
  static const int kForwardBlockIdxFieldNumber = 5;
  ::google::protobuf::int32 forward_block_idx() const;
  void set_forward_block_idx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.BlockDesc)
 private:
  void set_has_idx();
  void clear_has_idx();
  void set_has_parent_idx();
  void clear_has_parent_idx();
  void set_has_forward_block_idx();
  void clear_has_forward_block_idx();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::VarDesc > vars_;
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc > ops_;
  ::google::protobuf::int32 idx_;
  ::google::protobuf::int32 parent_idx_;
  ::google::protobuf::int32 forward_block_idx_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProgramDesc : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:paddle_mobile.framework.proto.ProgramDesc) */ {
 public:
  ProgramDesc();
  virtual ~ProgramDesc();

  ProgramDesc(const ProgramDesc& from);

  inline ProgramDesc& operator=(const ProgramDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProgramDesc(ProgramDesc&& from) noexcept
    : ProgramDesc() {
    *this = ::std::move(from);
  }

  inline ProgramDesc& operator=(ProgramDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProgramDesc& default_instance();

  static inline const ProgramDesc* internal_default_instance() {
    return reinterpret_cast<const ProgramDesc*>(
               &_ProgramDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(ProgramDesc* other);
  friend void swap(ProgramDesc& a, ProgramDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProgramDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  ProgramDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProgramDesc& from);
  void MergeFrom(const ProgramDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProgramDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .paddle_mobile.framework.proto.BlockDesc blocks = 1;
  int blocks_size() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 1;
  const ::paddle_mobile::framework::proto::BlockDesc& blocks(int index) const;
  ::paddle_mobile::framework::proto::BlockDesc* mutable_blocks(int index);
  ::paddle_mobile::framework::proto::BlockDesc* add_blocks();
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::BlockDesc >*
      mutable_blocks();
  const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::BlockDesc >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:paddle_mobile.framework.proto.ProgramDesc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::BlockDesc > blocks_;
  friend struct protobuf_framework_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OpDesc_Attr

// required string name = 1;
inline bool OpDesc_Attr::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpDesc_Attr::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpDesc_Attr::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpDesc_Attr::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& OpDesc_Attr::name() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.name)
  return name_.GetNoArena();
}
inline void OpDesc_Attr::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.name)
}
#if LANG_CXX11
inline void OpDesc_Attr::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:paddle_mobile.framework.proto.OpDesc.Attr.name)
}
#endif
inline void OpDesc_Attr::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpDesc.Attr.name)
}
inline void OpDesc_Attr::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpDesc.Attr.name)
}
inline ::std::string* OpDesc_Attr::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpDesc.Attr.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpDesc_Attr::release_name() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.OpDesc.Attr.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpDesc_Attr::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.OpDesc.Attr.name)
}

// required .paddle_mobile.framework.proto.AttrType type = 2;
inline bool OpDesc_Attr::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpDesc_Attr::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpDesc_Attr::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpDesc_Attr::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::paddle_mobile::framework::proto::AttrType OpDesc_Attr::type() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.type)
  return static_cast< ::paddle_mobile::framework::proto::AttrType >(type_);
}
inline void OpDesc_Attr::set_type(::paddle_mobile::framework::proto::AttrType value) {
  assert(::paddle_mobile::framework::proto::AttrType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.type)
}

// optional int32 i = 3;
inline bool OpDesc_Attr::has_i() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpDesc_Attr::set_has_i() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpDesc_Attr::clear_has_i() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpDesc_Attr::clear_i() {
  i_ = 0;
  clear_has_i();
}
inline ::google::protobuf::int32 OpDesc_Attr::i() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.i)
  return i_;
}
inline void OpDesc_Attr::set_i(::google::protobuf::int32 value) {
  set_has_i();
  i_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.i)
}

// optional float f = 4;
inline bool OpDesc_Attr::has_f() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OpDesc_Attr::set_has_f() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OpDesc_Attr::clear_has_f() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OpDesc_Attr::clear_f() {
  f_ = 0;
  clear_has_f();
}
inline float OpDesc_Attr::f() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.f)
  return f_;
}
inline void OpDesc_Attr::set_f(float value) {
  set_has_f();
  f_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.f)
}

// optional string s = 5;
inline bool OpDesc_Attr::has_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpDesc_Attr::set_has_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpDesc_Attr::clear_has_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpDesc_Attr::clear_s() {
  s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s();
}
inline const ::std::string& OpDesc_Attr::s() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.s)
  return s_.GetNoArena();
}
inline void OpDesc_Attr::set_s(const ::std::string& value) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.s)
}
#if LANG_CXX11
inline void OpDesc_Attr::set_s(::std::string&& value) {
  set_has_s();
  s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:paddle_mobile.framework.proto.OpDesc.Attr.s)
}
#endif
inline void OpDesc_Attr::set_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpDesc.Attr.s)
}
inline void OpDesc_Attr::set_s(const char* value, size_t size) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpDesc.Attr.s)
}
inline ::std::string* OpDesc_Attr::mutable_s() {
  set_has_s();
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpDesc.Attr.s)
  return s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpDesc_Attr::release_s() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.OpDesc.Attr.s)
  clear_has_s();
  return s_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpDesc_Attr::set_allocated_s(::std::string* s) {
  if (s != NULL) {
    set_has_s();
  } else {
    clear_has_s();
  }
  s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s);
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.OpDesc.Attr.s)
}

// repeated int32 ints = 6;
inline int OpDesc_Attr::ints_size() const {
  return ints_.size();
}
inline void OpDesc_Attr::clear_ints() {
  ints_.Clear();
}
inline ::google::protobuf::int32 OpDesc_Attr::ints(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.ints)
  return ints_.Get(index);
}
inline void OpDesc_Attr::set_ints(int index, ::google::protobuf::int32 value) {
  ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.ints)
}
inline void OpDesc_Attr::add_ints(::google::protobuf::int32 value) {
  ints_.Add(value);
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpDesc.Attr.ints)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
OpDesc_Attr::ints() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.OpDesc.Attr.ints)
  return ints_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
OpDesc_Attr::mutable_ints() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.OpDesc.Attr.ints)
  return &ints_;
}

// repeated float floats = 7;
inline int OpDesc_Attr::floats_size() const {
  return floats_.size();
}
inline void OpDesc_Attr::clear_floats() {
  floats_.Clear();
}
inline float OpDesc_Attr::floats(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.floats)
  return floats_.Get(index);
}
inline void OpDesc_Attr::set_floats(int index, float value) {
  floats_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.floats)
}
inline void OpDesc_Attr::add_floats(float value) {
  floats_.Add(value);
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpDesc.Attr.floats)
}
inline const ::google::protobuf::RepeatedField< float >&
OpDesc_Attr::floats() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.OpDesc.Attr.floats)
  return floats_;
}
inline ::google::protobuf::RepeatedField< float >*
OpDesc_Attr::mutable_floats() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.OpDesc.Attr.floats)
  return &floats_;
}

// repeated string strings = 8;
inline int OpDesc_Attr::strings_size() const {
  return strings_.size();
}
inline void OpDesc_Attr::clear_strings() {
  strings_.Clear();
}
inline const ::std::string& OpDesc_Attr::strings(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.strings)
  return strings_.Get(index);
}
inline ::std::string* OpDesc_Attr::mutable_strings(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpDesc.Attr.strings)
  return strings_.Mutable(index);
}
inline void OpDesc_Attr::set_strings(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.strings)
  strings_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OpDesc_Attr::set_strings(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.strings)
  strings_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OpDesc_Attr::set_strings(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpDesc.Attr.strings)
}
inline void OpDesc_Attr::set_strings(int index, const char* value, size_t size) {
  strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpDesc.Attr.strings)
}
inline ::std::string* OpDesc_Attr::add_strings() {
  // @@protoc_insertion_point(field_add_mutable:paddle_mobile.framework.proto.OpDesc.Attr.strings)
  return strings_.Add();
}
inline void OpDesc_Attr::add_strings(const ::std::string& value) {
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpDesc.Attr.strings)
}
#if LANG_CXX11
inline void OpDesc_Attr::add_strings(::std::string&& value) {
  strings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpDesc.Attr.strings)
}
#endif
inline void OpDesc_Attr::add_strings(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:paddle_mobile.framework.proto.OpDesc.Attr.strings)
}
inline void OpDesc_Attr::add_strings(const char* value, size_t size) {
  strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:paddle_mobile.framework.proto.OpDesc.Attr.strings)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OpDesc_Attr::strings() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.OpDesc.Attr.strings)
  return strings_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OpDesc_Attr::mutable_strings() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.OpDesc.Attr.strings)
  return &strings_;
}

// optional bool b = 10;
inline bool OpDesc_Attr::has_b() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OpDesc_Attr::set_has_b() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OpDesc_Attr::clear_has_b() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OpDesc_Attr::clear_b() {
  b_ = false;
  clear_has_b();
}
inline bool OpDesc_Attr::b() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.b)
  return b_;
}
inline void OpDesc_Attr::set_b(bool value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.b)
}

// repeated bool bools = 11;
inline int OpDesc_Attr::bools_size() const {
  return bools_.size();
}
inline void OpDesc_Attr::clear_bools() {
  bools_.Clear();
}
inline bool OpDesc_Attr::bools(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.bools)
  return bools_.Get(index);
}
inline void OpDesc_Attr::set_bools(int index, bool value) {
  bools_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.bools)
}
inline void OpDesc_Attr::add_bools(bool value) {
  bools_.Add(value);
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpDesc.Attr.bools)
}
inline const ::google::protobuf::RepeatedField< bool >&
OpDesc_Attr::bools() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.OpDesc.Attr.bools)
  return bools_;
}
inline ::google::protobuf::RepeatedField< bool >*
OpDesc_Attr::mutable_bools() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.OpDesc.Attr.bools)
  return &bools_;
}

// optional int32 block_idx = 12;
inline bool OpDesc_Attr::has_block_idx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OpDesc_Attr::set_has_block_idx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OpDesc_Attr::clear_has_block_idx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OpDesc_Attr::clear_block_idx() {
  block_idx_ = 0;
  clear_has_block_idx();
}
inline ::google::protobuf::int32 OpDesc_Attr::block_idx() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.block_idx)
  return block_idx_;
}
inline void OpDesc_Attr::set_block_idx(::google::protobuf::int32 value) {
  set_has_block_idx();
  block_idx_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.block_idx)
}

// optional int64 l = 13;
inline bool OpDesc_Attr::has_l() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OpDesc_Attr::set_has_l() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OpDesc_Attr::clear_has_l() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OpDesc_Attr::clear_l() {
  l_ = GOOGLE_LONGLONG(0);
  clear_has_l();
}
inline ::google::protobuf::int64 OpDesc_Attr::l() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Attr.l)
  return l_;
}
inline void OpDesc_Attr::set_l(::google::protobuf::int64 value) {
  set_has_l();
  l_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Attr.l)
}

// -------------------------------------------------------------------

// OpDesc_Var

// required string parameter = 1;
inline bool OpDesc_Var::has_parameter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpDesc_Var::set_has_parameter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpDesc_Var::clear_has_parameter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpDesc_Var::clear_parameter() {
  parameter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parameter();
}
inline const ::std::string& OpDesc_Var::parameter() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Var.parameter)
  return parameter_.GetNoArena();
}
inline void OpDesc_Var::set_parameter(const ::std::string& value) {
  set_has_parameter();
  parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Var.parameter)
}
#if LANG_CXX11
inline void OpDesc_Var::set_parameter(::std::string&& value) {
  set_has_parameter();
  parameter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:paddle_mobile.framework.proto.OpDesc.Var.parameter)
}
#endif
inline void OpDesc_Var::set_parameter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parameter();
  parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpDesc.Var.parameter)
}
inline void OpDesc_Var::set_parameter(const char* value, size_t size) {
  set_has_parameter();
  parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpDesc.Var.parameter)
}
inline ::std::string* OpDesc_Var::mutable_parameter() {
  set_has_parameter();
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpDesc.Var.parameter)
  return parameter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpDesc_Var::release_parameter() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.OpDesc.Var.parameter)
  clear_has_parameter();
  return parameter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpDesc_Var::set_allocated_parameter(::std::string* parameter) {
  if (parameter != NULL) {
    set_has_parameter();
  } else {
    clear_has_parameter();
  }
  parameter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parameter);
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.OpDesc.Var.parameter)
}

// repeated string arguments = 2;
inline int OpDesc_Var::arguments_size() const {
  return arguments_.size();
}
inline void OpDesc_Var::clear_arguments() {
  arguments_.Clear();
}
inline const ::std::string& OpDesc_Var::arguments(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.Var.arguments)
  return arguments_.Get(index);
}
inline ::std::string* OpDesc_Var::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpDesc.Var.arguments)
  return arguments_.Mutable(index);
}
inline void OpDesc_Var::set_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Var.arguments)
  arguments_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OpDesc_Var::set_arguments(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.Var.arguments)
  arguments_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OpDesc_Var::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpDesc.Var.arguments)
}
inline void OpDesc_Var::set_arguments(int index, const char* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpDesc.Var.arguments)
}
inline ::std::string* OpDesc_Var::add_arguments() {
  // @@protoc_insertion_point(field_add_mutable:paddle_mobile.framework.proto.OpDesc.Var.arguments)
  return arguments_.Add();
}
inline void OpDesc_Var::add_arguments(const ::std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpDesc.Var.arguments)
}
#if LANG_CXX11
inline void OpDesc_Var::add_arguments(::std::string&& value) {
  arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpDesc.Var.arguments)
}
#endif
inline void OpDesc_Var::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:paddle_mobile.framework.proto.OpDesc.Var.arguments)
}
inline void OpDesc_Var::add_arguments(const char* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:paddle_mobile.framework.proto.OpDesc.Var.arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OpDesc_Var::arguments() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.OpDesc.Var.arguments)
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OpDesc_Var::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.OpDesc.Var.arguments)
  return &arguments_;
}

// -------------------------------------------------------------------

// OpDesc

// required string type = 3;
inline bool OpDesc::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpDesc::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpDesc::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpDesc::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& OpDesc::type() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.type)
  return type_.GetNoArena();
}
inline void OpDesc::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.type)
}
#if LANG_CXX11
inline void OpDesc::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:paddle_mobile.framework.proto.OpDesc.type)
}
#endif
inline void OpDesc::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpDesc.type)
}
inline void OpDesc::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpDesc.type)
}
inline ::std::string* OpDesc::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpDesc.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpDesc::release_type() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.OpDesc.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpDesc::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.OpDesc.type)
}

// repeated .paddle_mobile.framework.proto.OpDesc.Var inputs = 1;
inline int OpDesc::inputs_size() const {
  return inputs_.size();
}
inline void OpDesc::clear_inputs() {
  inputs_.Clear();
}
inline const ::paddle_mobile::framework::proto::OpDesc_Var& OpDesc::inputs(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.inputs)
  return inputs_.Get(index);
}
inline ::paddle_mobile::framework::proto::OpDesc_Var* OpDesc::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpDesc.inputs)
  return inputs_.Mutable(index);
}
inline ::paddle_mobile::framework::proto::OpDesc_Var* OpDesc::add_inputs() {
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpDesc.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Var >*
OpDesc::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.OpDesc.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Var >&
OpDesc::inputs() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.OpDesc.inputs)
  return inputs_;
}

// repeated .paddle_mobile.framework.proto.OpDesc.Var outputs = 2;
inline int OpDesc::outputs_size() const {
  return outputs_.size();
}
inline void OpDesc::clear_outputs() {
  outputs_.Clear();
}
inline const ::paddle_mobile::framework::proto::OpDesc_Var& OpDesc::outputs(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.outputs)
  return outputs_.Get(index);
}
inline ::paddle_mobile::framework::proto::OpDesc_Var* OpDesc::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpDesc.outputs)
  return outputs_.Mutable(index);
}
inline ::paddle_mobile::framework::proto::OpDesc_Var* OpDesc::add_outputs() {
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpDesc.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Var >*
OpDesc::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.OpDesc.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Var >&
OpDesc::outputs() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.OpDesc.outputs)
  return outputs_;
}

// repeated .paddle_mobile.framework.proto.OpDesc.Attr attrs = 4;
inline int OpDesc::attrs_size() const {
  return attrs_.size();
}
inline void OpDesc::clear_attrs() {
  attrs_.Clear();
}
inline const ::paddle_mobile::framework::proto::OpDesc_Attr& OpDesc::attrs(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.attrs)
  return attrs_.Get(index);
}
inline ::paddle_mobile::framework::proto::OpDesc_Attr* OpDesc::mutable_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpDesc.attrs)
  return attrs_.Mutable(index);
}
inline ::paddle_mobile::framework::proto::OpDesc_Attr* OpDesc::add_attrs() {
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpDesc.attrs)
  return attrs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Attr >*
OpDesc::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.OpDesc.attrs)
  return &attrs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc_Attr >&
OpDesc::attrs() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.OpDesc.attrs)
  return attrs_;
}

// optional bool is_target = 5 [default = false];
inline bool OpDesc::has_is_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpDesc::set_has_is_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpDesc::clear_has_is_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpDesc::clear_is_target() {
  is_target_ = false;
  clear_has_is_target();
}
inline bool OpDesc::is_target() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpDesc.is_target)
  return is_target_;
}
inline void OpDesc::set_is_target(bool value) {
  set_has_is_target();
  is_target_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpDesc.is_target)
}

// -------------------------------------------------------------------

// OpProto_Var

// required string name = 1;
inline bool OpProto_Var::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpProto_Var::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpProto_Var::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpProto_Var::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& OpProto_Var::name() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.Var.name)
  return name_.GetNoArena();
}
inline void OpProto_Var::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpProto.Var.name)
}
#if LANG_CXX11
inline void OpProto_Var::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:paddle_mobile.framework.proto.OpProto.Var.name)
}
#endif
inline void OpProto_Var::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpProto.Var.name)
}
inline void OpProto_Var::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpProto.Var.name)
}
inline ::std::string* OpProto_Var::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpProto.Var.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpProto_Var::release_name() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.OpProto.Var.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpProto_Var::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.OpProto.Var.name)
}

// required string comment = 2;
inline bool OpProto_Var::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpProto_Var::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpProto_Var::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpProto_Var::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& OpProto_Var::comment() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.Var.comment)
  return comment_.GetNoArena();
}
inline void OpProto_Var::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpProto.Var.comment)
}
#if LANG_CXX11
inline void OpProto_Var::set_comment(::std::string&& value) {
  set_has_comment();
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:paddle_mobile.framework.proto.OpProto.Var.comment)
}
#endif
inline void OpProto_Var::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpProto.Var.comment)
}
inline void OpProto_Var::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpProto.Var.comment)
}
inline ::std::string* OpProto_Var::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpProto.Var.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpProto_Var::release_comment() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.OpProto.Var.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpProto_Var::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.OpProto.Var.comment)
}

// optional bool duplicable = 3 [default = false];
inline bool OpProto_Var::has_duplicable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpProto_Var::set_has_duplicable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpProto_Var::clear_has_duplicable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpProto_Var::clear_duplicable() {
  duplicable_ = false;
  clear_has_duplicable();
}
inline bool OpProto_Var::duplicable() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.Var.duplicable)
  return duplicable_;
}
inline void OpProto_Var::set_duplicable(bool value) {
  set_has_duplicable();
  duplicable_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpProto.Var.duplicable)
}

// optional bool intermediate = 4 [default = false];
inline bool OpProto_Var::has_intermediate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpProto_Var::set_has_intermediate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpProto_Var::clear_has_intermediate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpProto_Var::clear_intermediate() {
  intermediate_ = false;
  clear_has_intermediate();
}
inline bool OpProto_Var::intermediate() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.Var.intermediate)
  return intermediate_;
}
inline void OpProto_Var::set_intermediate(bool value) {
  set_has_intermediate();
  intermediate_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpProto.Var.intermediate)
}

// optional bool dispensable = 5 [default = false];
inline bool OpProto_Var::has_dispensable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OpProto_Var::set_has_dispensable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OpProto_Var::clear_has_dispensable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OpProto_Var::clear_dispensable() {
  dispensable_ = false;
  clear_has_dispensable();
}
inline bool OpProto_Var::dispensable() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.Var.dispensable)
  return dispensable_;
}
inline void OpProto_Var::set_dispensable(bool value) {
  set_has_dispensable();
  dispensable_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpProto.Var.dispensable)
}

// -------------------------------------------------------------------

// OpProto_Attr

// required string name = 1;
inline bool OpProto_Attr::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpProto_Attr::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpProto_Attr::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpProto_Attr::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& OpProto_Attr::name() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.Attr.name)
  return name_.GetNoArena();
}
inline void OpProto_Attr::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpProto.Attr.name)
}
#if LANG_CXX11
inline void OpProto_Attr::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:paddle_mobile.framework.proto.OpProto.Attr.name)
}
#endif
inline void OpProto_Attr::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpProto.Attr.name)
}
inline void OpProto_Attr::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpProto.Attr.name)
}
inline ::std::string* OpProto_Attr::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpProto.Attr.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpProto_Attr::release_name() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.OpProto.Attr.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpProto_Attr::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.OpProto.Attr.name)
}

// required .paddle_mobile.framework.proto.AttrType type = 2;
inline bool OpProto_Attr::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpProto_Attr::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpProto_Attr::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpProto_Attr::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::paddle_mobile::framework::proto::AttrType OpProto_Attr::type() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.Attr.type)
  return static_cast< ::paddle_mobile::framework::proto::AttrType >(type_);
}
inline void OpProto_Attr::set_type(::paddle_mobile::framework::proto::AttrType value) {
  assert(::paddle_mobile::framework::proto::AttrType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpProto.Attr.type)
}

// required string comment = 3;
inline bool OpProto_Attr::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpProto_Attr::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpProto_Attr::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpProto_Attr::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& OpProto_Attr::comment() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.Attr.comment)
  return comment_.GetNoArena();
}
inline void OpProto_Attr::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpProto.Attr.comment)
}
#if LANG_CXX11
inline void OpProto_Attr::set_comment(::std::string&& value) {
  set_has_comment();
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:paddle_mobile.framework.proto.OpProto.Attr.comment)
}
#endif
inline void OpProto_Attr::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpProto.Attr.comment)
}
inline void OpProto_Attr::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpProto.Attr.comment)
}
inline ::std::string* OpProto_Attr::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpProto.Attr.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpProto_Attr::release_comment() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.OpProto.Attr.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpProto_Attr::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.OpProto.Attr.comment)
}

// optional bool generated = 4 [default = false];
inline bool OpProto_Attr::has_generated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpProto_Attr::set_has_generated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpProto_Attr::clear_has_generated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpProto_Attr::clear_generated() {
  generated_ = false;
  clear_has_generated();
}
inline bool OpProto_Attr::generated() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.Attr.generated)
  return generated_;
}
inline void OpProto_Attr::set_generated(bool value) {
  set_has_generated();
  generated_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpProto.Attr.generated)
}

// -------------------------------------------------------------------

// OpProto

// required string type = 1;
inline bool OpProto::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpProto::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpProto::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& OpProto::type() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.type)
  return type_.GetNoArena();
}
inline void OpProto::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpProto.type)
}
#if LANG_CXX11
inline void OpProto::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:paddle_mobile.framework.proto.OpProto.type)
}
#endif
inline void OpProto::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpProto.type)
}
inline void OpProto::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpProto.type)
}
inline ::std::string* OpProto::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpProto.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpProto::release_type() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.OpProto.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpProto::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.OpProto.type)
}

// repeated .paddle_mobile.framework.proto.OpProto.Var inputs = 2;
inline int OpProto::inputs_size() const {
  return inputs_.size();
}
inline void OpProto::clear_inputs() {
  inputs_.Clear();
}
inline const ::paddle_mobile::framework::proto::OpProto_Var& OpProto::inputs(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.inputs)
  return inputs_.Get(index);
}
inline ::paddle_mobile::framework::proto::OpProto_Var* OpProto::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpProto.inputs)
  return inputs_.Mutable(index);
}
inline ::paddle_mobile::framework::proto::OpProto_Var* OpProto::add_inputs() {
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpProto.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Var >*
OpProto::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.OpProto.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Var >&
OpProto::inputs() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.OpProto.inputs)
  return inputs_;
}

// repeated .paddle_mobile.framework.proto.OpProto.Var outputs = 3;
inline int OpProto::outputs_size() const {
  return outputs_.size();
}
inline void OpProto::clear_outputs() {
  outputs_.Clear();
}
inline const ::paddle_mobile::framework::proto::OpProto_Var& OpProto::outputs(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.outputs)
  return outputs_.Get(index);
}
inline ::paddle_mobile::framework::proto::OpProto_Var* OpProto::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpProto.outputs)
  return outputs_.Mutable(index);
}
inline ::paddle_mobile::framework::proto::OpProto_Var* OpProto::add_outputs() {
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpProto.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Var >*
OpProto::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.OpProto.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Var >&
OpProto::outputs() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.OpProto.outputs)
  return outputs_;
}

// repeated .paddle_mobile.framework.proto.OpProto.Attr attrs = 4;
inline int OpProto::attrs_size() const {
  return attrs_.size();
}
inline void OpProto::clear_attrs() {
  attrs_.Clear();
}
inline const ::paddle_mobile::framework::proto::OpProto_Attr& OpProto::attrs(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.attrs)
  return attrs_.Get(index);
}
inline ::paddle_mobile::framework::proto::OpProto_Attr* OpProto::mutable_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpProto.attrs)
  return attrs_.Mutable(index);
}
inline ::paddle_mobile::framework::proto::OpProto_Attr* OpProto::add_attrs() {
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.OpProto.attrs)
  return attrs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Attr >*
OpProto::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.OpProto.attrs)
  return &attrs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpProto_Attr >&
OpProto::attrs() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.OpProto.attrs)
  return attrs_;
}

// required string comment = 5;
inline bool OpProto::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpProto::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpProto::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpProto::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& OpProto::comment() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.OpProto.comment)
  return comment_.GetNoArena();
}
inline void OpProto::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.OpProto.comment)
}
#if LANG_CXX11
inline void OpProto::set_comment(::std::string&& value) {
  set_has_comment();
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:paddle_mobile.framework.proto.OpProto.comment)
}
#endif
inline void OpProto::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.OpProto.comment)
}
inline void OpProto::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.OpProto.comment)
}
inline ::std::string* OpProto::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.OpProto.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpProto::release_comment() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.OpProto.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpProto::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.OpProto.comment)
}

// -------------------------------------------------------------------

// VarType_TensorDesc

// required .paddle_mobile.framework.proto.VarType.Type data_type = 1;
inline bool VarType_TensorDesc::has_data_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarType_TensorDesc::set_has_data_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarType_TensorDesc::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarType_TensorDesc::clear_data_type() {
  data_type_ = 0;
  clear_has_data_type();
}
inline ::paddle_mobile::framework::proto::VarType_Type VarType_TensorDesc::data_type() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.TensorDesc.data_type)
  return static_cast< ::paddle_mobile::framework::proto::VarType_Type >(data_type_);
}
inline void VarType_TensorDesc::set_data_type(::paddle_mobile::framework::proto::VarType_Type value) {
  assert(::paddle_mobile::framework::proto::VarType_Type_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.VarType.TensorDesc.data_type)
}

// repeated int64 dims = 2;
inline int VarType_TensorDesc::dims_size() const {
  return dims_.size();
}
inline void VarType_TensorDesc::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int64 VarType_TensorDesc::dims(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.TensorDesc.dims)
  return dims_.Get(index);
}
inline void VarType_TensorDesc::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.VarType.TensorDesc.dims)
}
inline void VarType_TensorDesc::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.VarType.TensorDesc.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
VarType_TensorDesc::dims() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.VarType.TensorDesc.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
VarType_TensorDesc::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.VarType.TensorDesc.dims)
  return &dims_;
}

// -------------------------------------------------------------------

// VarType_LoDTensorDesc

// required .paddle_mobile.framework.proto.VarType.TensorDesc tensor = 1;
inline bool VarType_LoDTensorDesc::has_tensor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarType_LoDTensorDesc::set_has_tensor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarType_LoDTensorDesc::clear_has_tensor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarType_LoDTensorDesc::clear_tensor() {
  if (tensor_ != NULL) tensor_->::paddle_mobile::framework::proto::VarType_TensorDesc::Clear();
  clear_has_tensor();
}
inline const ::paddle_mobile::framework::proto::VarType_TensorDesc& VarType_LoDTensorDesc::tensor() const {
  const ::paddle_mobile::framework::proto::VarType_TensorDesc* p = tensor_;
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.LoDTensorDesc.tensor)
  return p != NULL ? *p : *reinterpret_cast<const ::paddle_mobile::framework::proto::VarType_TensorDesc*>(
      &::paddle_mobile::framework::proto::_VarType_TensorDesc_default_instance_);
}
inline ::paddle_mobile::framework::proto::VarType_TensorDesc* VarType_LoDTensorDesc::mutable_tensor() {
  set_has_tensor();
  if (tensor_ == NULL) {
    tensor_ = new ::paddle_mobile::framework::proto::VarType_TensorDesc;
  }
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.VarType.LoDTensorDesc.tensor)
  return tensor_;
}
inline ::paddle_mobile::framework::proto::VarType_TensorDesc* VarType_LoDTensorDesc::release_tensor() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.VarType.LoDTensorDesc.tensor)
  clear_has_tensor();
  ::paddle_mobile::framework::proto::VarType_TensorDesc* temp = tensor_;
  tensor_ = NULL;
  return temp;
}
inline void VarType_LoDTensorDesc::set_allocated_tensor(::paddle_mobile::framework::proto::VarType_TensorDesc* tensor) {
  delete tensor_;
  tensor_ = tensor;
  if (tensor) {
    set_has_tensor();
  } else {
    clear_has_tensor();
  }
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.VarType.LoDTensorDesc.tensor)
}

// optional int32 lod_level = 2 [default = 0];
inline bool VarType_LoDTensorDesc::has_lod_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarType_LoDTensorDesc::set_has_lod_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarType_LoDTensorDesc::clear_has_lod_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarType_LoDTensorDesc::clear_lod_level() {
  lod_level_ = 0;
  clear_has_lod_level();
}
inline ::google::protobuf::int32 VarType_LoDTensorDesc::lod_level() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.LoDTensorDesc.lod_level)
  return lod_level_;
}
inline void VarType_LoDTensorDesc::set_lod_level(::google::protobuf::int32 value) {
  set_has_lod_level();
  lod_level_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.VarType.LoDTensorDesc.lod_level)
}

// -------------------------------------------------------------------

// VarType_LoDTensorArrayDesc

// required .paddle_mobile.framework.proto.VarType.TensorDesc tensor = 1;
inline bool VarType_LoDTensorArrayDesc::has_tensor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarType_LoDTensorArrayDesc::set_has_tensor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarType_LoDTensorArrayDesc::clear_has_tensor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarType_LoDTensorArrayDesc::clear_tensor() {
  if (tensor_ != NULL) tensor_->::paddle_mobile::framework::proto::VarType_TensorDesc::Clear();
  clear_has_tensor();
}
inline const ::paddle_mobile::framework::proto::VarType_TensorDesc& VarType_LoDTensorArrayDesc::tensor() const {
  const ::paddle_mobile::framework::proto::VarType_TensorDesc* p = tensor_;
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.LoDTensorArrayDesc.tensor)
  return p != NULL ? *p : *reinterpret_cast<const ::paddle_mobile::framework::proto::VarType_TensorDesc*>(
      &::paddle_mobile::framework::proto::_VarType_TensorDesc_default_instance_);
}
inline ::paddle_mobile::framework::proto::VarType_TensorDesc* VarType_LoDTensorArrayDesc::mutable_tensor() {
  set_has_tensor();
  if (tensor_ == NULL) {
    tensor_ = new ::paddle_mobile::framework::proto::VarType_TensorDesc;
  }
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.VarType.LoDTensorArrayDesc.tensor)
  return tensor_;
}
inline ::paddle_mobile::framework::proto::VarType_TensorDesc* VarType_LoDTensorArrayDesc::release_tensor() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.VarType.LoDTensorArrayDesc.tensor)
  clear_has_tensor();
  ::paddle_mobile::framework::proto::VarType_TensorDesc* temp = tensor_;
  tensor_ = NULL;
  return temp;
}
inline void VarType_LoDTensorArrayDesc::set_allocated_tensor(::paddle_mobile::framework::proto::VarType_TensorDesc* tensor) {
  delete tensor_;
  tensor_ = tensor;
  if (tensor) {
    set_has_tensor();
  } else {
    clear_has_tensor();
  }
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.VarType.LoDTensorArrayDesc.tensor)
}

// optional int32 lod_level = 2 [default = 0];
inline bool VarType_LoDTensorArrayDesc::has_lod_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarType_LoDTensorArrayDesc::set_has_lod_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarType_LoDTensorArrayDesc::clear_has_lod_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarType_LoDTensorArrayDesc::clear_lod_level() {
  lod_level_ = 0;
  clear_has_lod_level();
}
inline ::google::protobuf::int32 VarType_LoDTensorArrayDesc::lod_level() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.LoDTensorArrayDesc.lod_level)
  return lod_level_;
}
inline void VarType_LoDTensorArrayDesc::set_lod_level(::google::protobuf::int32 value) {
  set_has_lod_level();
  lod_level_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.VarType.LoDTensorArrayDesc.lod_level)
}

// -------------------------------------------------------------------

// VarType_ReaderDesc

// repeated .paddle_mobile.framework.proto.VarType.LoDTensorDesc lod_tensor = 1;
inline int VarType_ReaderDesc::lod_tensor_size() const {
  return lod_tensor_.size();
}
inline void VarType_ReaderDesc::clear_lod_tensor() {
  lod_tensor_.Clear();
}
inline const ::paddle_mobile::framework::proto::VarType_LoDTensorDesc& VarType_ReaderDesc::lod_tensor(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.ReaderDesc.lod_tensor)
  return lod_tensor_.Get(index);
}
inline ::paddle_mobile::framework::proto::VarType_LoDTensorDesc* VarType_ReaderDesc::mutable_lod_tensor(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.VarType.ReaderDesc.lod_tensor)
  return lod_tensor_.Mutable(index);
}
inline ::paddle_mobile::framework::proto::VarType_LoDTensorDesc* VarType_ReaderDesc::add_lod_tensor() {
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.VarType.ReaderDesc.lod_tensor)
  return lod_tensor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::VarType_LoDTensorDesc >*
VarType_ReaderDesc::mutable_lod_tensor() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.VarType.ReaderDesc.lod_tensor)
  return &lod_tensor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::VarType_LoDTensorDesc >&
VarType_ReaderDesc::lod_tensor() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.VarType.ReaderDesc.lod_tensor)
  return lod_tensor_;
}

// -------------------------------------------------------------------

// VarType_ChannelDesc

// required .paddle_mobile.framework.proto.VarType.Type data_type = 1;
inline bool VarType_ChannelDesc::has_data_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarType_ChannelDesc::set_has_data_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarType_ChannelDesc::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarType_ChannelDesc::clear_data_type() {
  data_type_ = 0;
  clear_has_data_type();
}
inline ::paddle_mobile::framework::proto::VarType_Type VarType_ChannelDesc::data_type() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.ChannelDesc.data_type)
  return static_cast< ::paddle_mobile::framework::proto::VarType_Type >(data_type_);
}
inline void VarType_ChannelDesc::set_data_type(::paddle_mobile::framework::proto::VarType_Type value) {
  assert(::paddle_mobile::framework::proto::VarType_Type_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.VarType.ChannelDesc.data_type)
}

// required int64 capacity = 2;
inline bool VarType_ChannelDesc::has_capacity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarType_ChannelDesc::set_has_capacity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarType_ChannelDesc::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarType_ChannelDesc::clear_capacity() {
  capacity_ = GOOGLE_LONGLONG(0);
  clear_has_capacity();
}
inline ::google::protobuf::int64 VarType_ChannelDesc::capacity() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.ChannelDesc.capacity)
  return capacity_;
}
inline void VarType_ChannelDesc::set_capacity(::google::protobuf::int64 value) {
  set_has_capacity();
  capacity_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.VarType.ChannelDesc.capacity)
}

// -------------------------------------------------------------------

// VarType_Tuple

// repeated .paddle_mobile.framework.proto.VarType.Type element_type = 1;
inline int VarType_Tuple::element_type_size() const {
  return element_type_.size();
}
inline void VarType_Tuple::clear_element_type() {
  element_type_.Clear();
}
inline ::paddle_mobile::framework::proto::VarType_Type VarType_Tuple::element_type(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.Tuple.element_type)
  return static_cast< ::paddle_mobile::framework::proto::VarType_Type >(element_type_.Get(index));
}
inline void VarType_Tuple::set_element_type(int index, ::paddle_mobile::framework::proto::VarType_Type value) {
  assert(::paddle_mobile::framework::proto::VarType_Type_IsValid(value));
  element_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.VarType.Tuple.element_type)
}
inline void VarType_Tuple::add_element_type(::paddle_mobile::framework::proto::VarType_Type value) {
  assert(::paddle_mobile::framework::proto::VarType_Type_IsValid(value));
  element_type_.Add(value);
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.VarType.Tuple.element_type)
}
inline const ::google::protobuf::RepeatedField<int>&
VarType_Tuple::element_type() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.VarType.Tuple.element_type)
  return element_type_;
}
inline ::google::protobuf::RepeatedField<int>*
VarType_Tuple::mutable_element_type() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.VarType.Tuple.element_type)
  return &element_type_;
}

// -------------------------------------------------------------------

// VarType

// required .paddle_mobile.framework.proto.VarType.Type type = 1;
inline bool VarType::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VarType::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VarType::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VarType::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::paddle_mobile::framework::proto::VarType_Type VarType::type() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.type)
  return static_cast< ::paddle_mobile::framework::proto::VarType_Type >(type_);
}
inline void VarType::set_type(::paddle_mobile::framework::proto::VarType_Type value) {
  assert(::paddle_mobile::framework::proto::VarType_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.VarType.type)
}

// optional .paddle_mobile.framework.proto.VarType.TensorDesc selected_rows = 2;
inline bool VarType::has_selected_rows() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarType::set_has_selected_rows() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarType::clear_has_selected_rows() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarType::clear_selected_rows() {
  if (selected_rows_ != NULL) selected_rows_->::paddle_mobile::framework::proto::VarType_TensorDesc::Clear();
  clear_has_selected_rows();
}
inline const ::paddle_mobile::framework::proto::VarType_TensorDesc& VarType::selected_rows() const {
  const ::paddle_mobile::framework::proto::VarType_TensorDesc* p = selected_rows_;
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.selected_rows)
  return p != NULL ? *p : *reinterpret_cast<const ::paddle_mobile::framework::proto::VarType_TensorDesc*>(
      &::paddle_mobile::framework::proto::_VarType_TensorDesc_default_instance_);
}
inline ::paddle_mobile::framework::proto::VarType_TensorDesc* VarType::mutable_selected_rows() {
  set_has_selected_rows();
  if (selected_rows_ == NULL) {
    selected_rows_ = new ::paddle_mobile::framework::proto::VarType_TensorDesc;
  }
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.VarType.selected_rows)
  return selected_rows_;
}
inline ::paddle_mobile::framework::proto::VarType_TensorDesc* VarType::release_selected_rows() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.VarType.selected_rows)
  clear_has_selected_rows();
  ::paddle_mobile::framework::proto::VarType_TensorDesc* temp = selected_rows_;
  selected_rows_ = NULL;
  return temp;
}
inline void VarType::set_allocated_selected_rows(::paddle_mobile::framework::proto::VarType_TensorDesc* selected_rows) {
  delete selected_rows_;
  selected_rows_ = selected_rows;
  if (selected_rows) {
    set_has_selected_rows();
  } else {
    clear_has_selected_rows();
  }
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.VarType.selected_rows)
}

// optional .paddle_mobile.framework.proto.VarType.LoDTensorDesc lod_tensor = 3;
inline bool VarType::has_lod_tensor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarType::set_has_lod_tensor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarType::clear_has_lod_tensor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarType::clear_lod_tensor() {
  if (lod_tensor_ != NULL) lod_tensor_->::paddle_mobile::framework::proto::VarType_LoDTensorDesc::Clear();
  clear_has_lod_tensor();
}
inline const ::paddle_mobile::framework::proto::VarType_LoDTensorDesc& VarType::lod_tensor() const {
  const ::paddle_mobile::framework::proto::VarType_LoDTensorDesc* p = lod_tensor_;
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.lod_tensor)
  return p != NULL ? *p : *reinterpret_cast<const ::paddle_mobile::framework::proto::VarType_LoDTensorDesc*>(
      &::paddle_mobile::framework::proto::_VarType_LoDTensorDesc_default_instance_);
}
inline ::paddle_mobile::framework::proto::VarType_LoDTensorDesc* VarType::mutable_lod_tensor() {
  set_has_lod_tensor();
  if (lod_tensor_ == NULL) {
    lod_tensor_ = new ::paddle_mobile::framework::proto::VarType_LoDTensorDesc;
  }
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.VarType.lod_tensor)
  return lod_tensor_;
}
inline ::paddle_mobile::framework::proto::VarType_LoDTensorDesc* VarType::release_lod_tensor() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.VarType.lod_tensor)
  clear_has_lod_tensor();
  ::paddle_mobile::framework::proto::VarType_LoDTensorDesc* temp = lod_tensor_;
  lod_tensor_ = NULL;
  return temp;
}
inline void VarType::set_allocated_lod_tensor(::paddle_mobile::framework::proto::VarType_LoDTensorDesc* lod_tensor) {
  delete lod_tensor_;
  lod_tensor_ = lod_tensor;
  if (lod_tensor) {
    set_has_lod_tensor();
  } else {
    clear_has_lod_tensor();
  }
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.VarType.lod_tensor)
}

// optional .paddle_mobile.framework.proto.VarType.LoDTensorArrayDesc tensor_array = 4;
inline bool VarType::has_tensor_array() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VarType::set_has_tensor_array() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VarType::clear_has_tensor_array() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VarType::clear_tensor_array() {
  if (tensor_array_ != NULL) tensor_array_->::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc::Clear();
  clear_has_tensor_array();
}
inline const ::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc& VarType::tensor_array() const {
  const ::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc* p = tensor_array_;
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.tensor_array)
  return p != NULL ? *p : *reinterpret_cast<const ::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc*>(
      &::paddle_mobile::framework::proto::_VarType_LoDTensorArrayDesc_default_instance_);
}
inline ::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc* VarType::mutable_tensor_array() {
  set_has_tensor_array();
  if (tensor_array_ == NULL) {
    tensor_array_ = new ::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc;
  }
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.VarType.tensor_array)
  return tensor_array_;
}
inline ::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc* VarType::release_tensor_array() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.VarType.tensor_array)
  clear_has_tensor_array();
  ::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc* temp = tensor_array_;
  tensor_array_ = NULL;
  return temp;
}
inline void VarType::set_allocated_tensor_array(::paddle_mobile::framework::proto::VarType_LoDTensorArrayDesc* tensor_array) {
  delete tensor_array_;
  tensor_array_ = tensor_array;
  if (tensor_array) {
    set_has_tensor_array();
  } else {
    clear_has_tensor_array();
  }
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.VarType.tensor_array)
}

// optional .paddle_mobile.framework.proto.VarType.ReaderDesc reader = 5;
inline bool VarType::has_reader() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VarType::set_has_reader() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VarType::clear_has_reader() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VarType::clear_reader() {
  if (reader_ != NULL) reader_->::paddle_mobile::framework::proto::VarType_ReaderDesc::Clear();
  clear_has_reader();
}
inline const ::paddle_mobile::framework::proto::VarType_ReaderDesc& VarType::reader() const {
  const ::paddle_mobile::framework::proto::VarType_ReaderDesc* p = reader_;
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.reader)
  return p != NULL ? *p : *reinterpret_cast<const ::paddle_mobile::framework::proto::VarType_ReaderDesc*>(
      &::paddle_mobile::framework::proto::_VarType_ReaderDesc_default_instance_);
}
inline ::paddle_mobile::framework::proto::VarType_ReaderDesc* VarType::mutable_reader() {
  set_has_reader();
  if (reader_ == NULL) {
    reader_ = new ::paddle_mobile::framework::proto::VarType_ReaderDesc;
  }
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.VarType.reader)
  return reader_;
}
inline ::paddle_mobile::framework::proto::VarType_ReaderDesc* VarType::release_reader() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.VarType.reader)
  clear_has_reader();
  ::paddle_mobile::framework::proto::VarType_ReaderDesc* temp = reader_;
  reader_ = NULL;
  return temp;
}
inline void VarType::set_allocated_reader(::paddle_mobile::framework::proto::VarType_ReaderDesc* reader) {
  delete reader_;
  reader_ = reader;
  if (reader) {
    set_has_reader();
  } else {
    clear_has_reader();
  }
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.VarType.reader)
}

// optional .paddle_mobile.framework.proto.VarType.ChannelDesc channel = 6;
inline bool VarType::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VarType::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VarType::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VarType::clear_channel() {
  if (channel_ != NULL) channel_->::paddle_mobile::framework::proto::VarType_ChannelDesc::Clear();
  clear_has_channel();
}
inline const ::paddle_mobile::framework::proto::VarType_ChannelDesc& VarType::channel() const {
  const ::paddle_mobile::framework::proto::VarType_ChannelDesc* p = channel_;
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.channel)
  return p != NULL ? *p : *reinterpret_cast<const ::paddle_mobile::framework::proto::VarType_ChannelDesc*>(
      &::paddle_mobile::framework::proto::_VarType_ChannelDesc_default_instance_);
}
inline ::paddle_mobile::framework::proto::VarType_ChannelDesc* VarType::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    channel_ = new ::paddle_mobile::framework::proto::VarType_ChannelDesc;
  }
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.VarType.channel)
  return channel_;
}
inline ::paddle_mobile::framework::proto::VarType_ChannelDesc* VarType::release_channel() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.VarType.channel)
  clear_has_channel();
  ::paddle_mobile::framework::proto::VarType_ChannelDesc* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline void VarType::set_allocated_channel(::paddle_mobile::framework::proto::VarType_ChannelDesc* channel) {
  delete channel_;
  channel_ = channel;
  if (channel) {
    set_has_channel();
  } else {
    clear_has_channel();
  }
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.VarType.channel)
}

// optional .paddle_mobile.framework.proto.VarType.Tuple tuple = 7;
inline bool VarType::has_tuple() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VarType::set_has_tuple() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VarType::clear_has_tuple() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VarType::clear_tuple() {
  if (tuple_ != NULL) tuple_->::paddle_mobile::framework::proto::VarType_Tuple::Clear();
  clear_has_tuple();
}
inline const ::paddle_mobile::framework::proto::VarType_Tuple& VarType::tuple() const {
  const ::paddle_mobile::framework::proto::VarType_Tuple* p = tuple_;
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarType.tuple)
  return p != NULL ? *p : *reinterpret_cast<const ::paddle_mobile::framework::proto::VarType_Tuple*>(
      &::paddle_mobile::framework::proto::_VarType_Tuple_default_instance_);
}
inline ::paddle_mobile::framework::proto::VarType_Tuple* VarType::mutable_tuple() {
  set_has_tuple();
  if (tuple_ == NULL) {
    tuple_ = new ::paddle_mobile::framework::proto::VarType_Tuple;
  }
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.VarType.tuple)
  return tuple_;
}
inline ::paddle_mobile::framework::proto::VarType_Tuple* VarType::release_tuple() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.VarType.tuple)
  clear_has_tuple();
  ::paddle_mobile::framework::proto::VarType_Tuple* temp = tuple_;
  tuple_ = NULL;
  return temp;
}
inline void VarType::set_allocated_tuple(::paddle_mobile::framework::proto::VarType_Tuple* tuple) {
  delete tuple_;
  tuple_ = tuple;
  if (tuple) {
    set_has_tuple();
  } else {
    clear_has_tuple();
  }
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.VarType.tuple)
}

// -------------------------------------------------------------------

// VarDesc

// required string name = 1;
inline bool VarDesc::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarDesc::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarDesc::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarDesc::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& VarDesc::name() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarDesc.name)
  return name_.GetNoArena();
}
inline void VarDesc::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.VarDesc.name)
}
#if LANG_CXX11
inline void VarDesc::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:paddle_mobile.framework.proto.VarDesc.name)
}
#endif
inline void VarDesc::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:paddle_mobile.framework.proto.VarDesc.name)
}
inline void VarDesc::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:paddle_mobile.framework.proto.VarDesc.name)
}
inline ::std::string* VarDesc::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.VarDesc.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VarDesc::release_name() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.VarDesc.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarDesc::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.VarDesc.name)
}

// required .paddle_mobile.framework.proto.VarType type = 2;
inline bool VarDesc::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarDesc::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarDesc::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarDesc::clear_type() {
  if (type_ != NULL) type_->::paddle_mobile::framework::proto::VarType::Clear();
  clear_has_type();
}
inline const ::paddle_mobile::framework::proto::VarType& VarDesc::type() const {
  const ::paddle_mobile::framework::proto::VarType* p = type_;
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarDesc.type)
  return p != NULL ? *p : *reinterpret_cast<const ::paddle_mobile::framework::proto::VarType*>(
      &::paddle_mobile::framework::proto::_VarType_default_instance_);
}
inline ::paddle_mobile::framework::proto::VarType* VarDesc::mutable_type() {
  set_has_type();
  if (type_ == NULL) {
    type_ = new ::paddle_mobile::framework::proto::VarType;
  }
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.VarDesc.type)
  return type_;
}
inline ::paddle_mobile::framework::proto::VarType* VarDesc::release_type() {
  // @@protoc_insertion_point(field_release:paddle_mobile.framework.proto.VarDesc.type)
  clear_has_type();
  ::paddle_mobile::framework::proto::VarType* temp = type_;
  type_ = NULL;
  return temp;
}
inline void VarDesc::set_allocated_type(::paddle_mobile::framework::proto::VarType* type) {
  delete type_;
  type_ = type;
  if (type) {
    set_has_type();
  } else {
    clear_has_type();
  }
  // @@protoc_insertion_point(field_set_allocated:paddle_mobile.framework.proto.VarDesc.type)
}

// optional bool persistable = 3 [default = false];
inline bool VarDesc::has_persistable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VarDesc::set_has_persistable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VarDesc::clear_has_persistable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VarDesc::clear_persistable() {
  persistable_ = false;
  clear_has_persistable();
}
inline bool VarDesc::persistable() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.VarDesc.persistable)
  return persistable_;
}
inline void VarDesc::set_persistable(bool value) {
  set_has_persistable();
  persistable_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.VarDesc.persistable)
}

// -------------------------------------------------------------------

// BlockDesc

// required int32 idx = 1;
inline bool BlockDesc::has_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockDesc::set_has_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockDesc::clear_has_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockDesc::clear_idx() {
  idx_ = 0;
  clear_has_idx();
}
inline ::google::protobuf::int32 BlockDesc::idx() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.BlockDesc.idx)
  return idx_;
}
inline void BlockDesc::set_idx(::google::protobuf::int32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.BlockDesc.idx)
}

// required int32 parent_idx = 2;
inline bool BlockDesc::has_parent_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockDesc::set_has_parent_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockDesc::clear_has_parent_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockDesc::clear_parent_idx() {
  parent_idx_ = 0;
  clear_has_parent_idx();
}
inline ::google::protobuf::int32 BlockDesc::parent_idx() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.BlockDesc.parent_idx)
  return parent_idx_;
}
inline void BlockDesc::set_parent_idx(::google::protobuf::int32 value) {
  set_has_parent_idx();
  parent_idx_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.BlockDesc.parent_idx)
}

// repeated .paddle_mobile.framework.proto.VarDesc vars = 3;
inline int BlockDesc::vars_size() const {
  return vars_.size();
}
inline void BlockDesc::clear_vars() {
  vars_.Clear();
}
inline const ::paddle_mobile::framework::proto::VarDesc& BlockDesc::vars(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.BlockDesc.vars)
  return vars_.Get(index);
}
inline ::paddle_mobile::framework::proto::VarDesc* BlockDesc::mutable_vars(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.BlockDesc.vars)
  return vars_.Mutable(index);
}
inline ::paddle_mobile::framework::proto::VarDesc* BlockDesc::add_vars() {
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.BlockDesc.vars)
  return vars_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::VarDesc >*
BlockDesc::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.BlockDesc.vars)
  return &vars_;
}
inline const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::VarDesc >&
BlockDesc::vars() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.BlockDesc.vars)
  return vars_;
}

// repeated .paddle_mobile.framework.proto.OpDesc ops = 4;
inline int BlockDesc::ops_size() const {
  return ops_.size();
}
inline void BlockDesc::clear_ops() {
  ops_.Clear();
}
inline const ::paddle_mobile::framework::proto::OpDesc& BlockDesc::ops(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.BlockDesc.ops)
  return ops_.Get(index);
}
inline ::paddle_mobile::framework::proto::OpDesc* BlockDesc::mutable_ops(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.BlockDesc.ops)
  return ops_.Mutable(index);
}
inline ::paddle_mobile::framework::proto::OpDesc* BlockDesc::add_ops() {
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.BlockDesc.ops)
  return ops_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc >*
BlockDesc::mutable_ops() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.BlockDesc.ops)
  return &ops_;
}
inline const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::OpDesc >&
BlockDesc::ops() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.BlockDesc.ops)
  return ops_;
}

// optional int32 forward_block_idx = 5 [default = -1];
inline bool BlockDesc::has_forward_block_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockDesc::set_has_forward_block_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockDesc::clear_has_forward_block_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockDesc::clear_forward_block_idx() {
  forward_block_idx_ = -1;
  clear_has_forward_block_idx();
}
inline ::google::protobuf::int32 BlockDesc::forward_block_idx() const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.BlockDesc.forward_block_idx)
  return forward_block_idx_;
}
inline void BlockDesc::set_forward_block_idx(::google::protobuf::int32 value) {
  set_has_forward_block_idx();
  forward_block_idx_ = value;
  // @@protoc_insertion_point(field_set:paddle_mobile.framework.proto.BlockDesc.forward_block_idx)
}

// -------------------------------------------------------------------

// ProgramDesc

// repeated .paddle_mobile.framework.proto.BlockDesc blocks = 1;
inline int ProgramDesc::blocks_size() const {
  return blocks_.size();
}
inline void ProgramDesc::clear_blocks() {
  blocks_.Clear();
}
inline const ::paddle_mobile::framework::proto::BlockDesc& ProgramDesc::blocks(int index) const {
  // @@protoc_insertion_point(field_get:paddle_mobile.framework.proto.ProgramDesc.blocks)
  return blocks_.Get(index);
}
inline ::paddle_mobile::framework::proto::BlockDesc* ProgramDesc::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:paddle_mobile.framework.proto.ProgramDesc.blocks)
  return blocks_.Mutable(index);
}
inline ::paddle_mobile::framework::proto::BlockDesc* ProgramDesc::add_blocks() {
  // @@protoc_insertion_point(field_add:paddle_mobile.framework.proto.ProgramDesc.blocks)
  return blocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::BlockDesc >*
ProgramDesc::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:paddle_mobile.framework.proto.ProgramDesc.blocks)
  return &blocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::paddle_mobile::framework::proto::BlockDesc >&
ProgramDesc::blocks() const {
  // @@protoc_insertion_point(field_list:paddle_mobile.framework.proto.ProgramDesc.blocks)
  return blocks_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace proto
}  // namespace framework
}  // namespace paddle_mobile

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::paddle_mobile::framework::proto::VarType_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::paddle_mobile::framework::proto::AttrType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_framework_2eproto__INCLUDED
