// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FRAMEWORK_PADDLE_LITE_FBS_PROTO_H_
#define FLATBUFFERS_GENERATED_FRAMEWORK_PADDLE_LITE_FBS_PROTO_H_

#include "flatbuffers/flatbuffers.h"

namespace paddle {
namespace lite {
namespace fbs {
namespace proto {

struct Version;
struct VersionBuilder;
struct VersionT;

struct OpDesc;
struct OpDescBuilder;
struct OpDescT;

namespace OpDesc_ {

struct Attr;
struct AttrBuilder;
struct AttrT;

struct Var;
struct VarBuilder;
struct VarT;

}  // namespace OpDesc_

struct VarType;
struct VarTypeBuilder;
struct VarTypeT;

namespace VarType_ {

struct TensorDesc;
struct TensorDescBuilder;
struct TensorDescT;

struct LoDTensorDesc;
struct LoDTensorDescBuilder;
struct LoDTensorDescT;

struct LoDTensorArrayDesc;
struct LoDTensorArrayDescBuilder;
struct LoDTensorArrayDescT;

struct ReaderDesc;
struct ReaderDescBuilder;
struct ReaderDescT;

struct Tuple;
struct TupleBuilder;
struct TupleT;

}  // namespace VarType_

struct VarDesc;
struct VarDescBuilder;
struct VarDescT;

struct BlockDesc;
struct BlockDescBuilder;
struct BlockDescT;

struct OpVersion;
struct OpVersionBuilder;
struct OpVersionT;

struct OpVersionMap;
struct OpVersionMapBuilder;
struct OpVersionMapT;

namespace OpVersionMap_ {

struct OpVersionPair;
struct OpVersionPairBuilder;
struct OpVersionPairT;

}  // namespace OpVersionMap_

struct ProgramDesc;
struct ProgramDescBuilder;
struct ProgramDescT;

bool operator==(const VersionT &lhs, const VersionT &rhs);
bool operator!=(const VersionT &lhs, const VersionT &rhs);
bool operator==(const OpDescT &lhs, const OpDescT &rhs);
bool operator!=(const OpDescT &lhs, const OpDescT &rhs);
namespace OpDesc_ {

bool operator==(const AttrT &lhs, const AttrT &rhs);
bool operator!=(const AttrT &lhs, const AttrT &rhs);
bool operator==(const VarT &lhs, const VarT &rhs);
bool operator!=(const VarT &lhs, const VarT &rhs);
}  // namespace OpDesc_

bool operator==(const VarTypeT &lhs, const VarTypeT &rhs);
bool operator!=(const VarTypeT &lhs, const VarTypeT &rhs);
namespace VarType_ {

bool operator==(const TensorDescT &lhs, const TensorDescT &rhs);
bool operator!=(const TensorDescT &lhs, const TensorDescT &rhs);
bool operator==(const LoDTensorDescT &lhs, const LoDTensorDescT &rhs);
bool operator!=(const LoDTensorDescT &lhs, const LoDTensorDescT &rhs);
bool operator==(const LoDTensorArrayDescT &lhs, const LoDTensorArrayDescT &rhs);
bool operator!=(const LoDTensorArrayDescT &lhs, const LoDTensorArrayDescT &rhs);
bool operator==(const ReaderDescT &lhs, const ReaderDescT &rhs);
bool operator!=(const ReaderDescT &lhs, const ReaderDescT &rhs);
bool operator==(const TupleT &lhs, const TupleT &rhs);
bool operator!=(const TupleT &lhs, const TupleT &rhs);
}  // namespace VarType_

bool operator==(const VarDescT &lhs, const VarDescT &rhs);
bool operator!=(const VarDescT &lhs, const VarDescT &rhs);
bool operator==(const BlockDescT &lhs, const BlockDescT &rhs);
bool operator!=(const BlockDescT &lhs, const BlockDescT &rhs);
bool operator==(const OpVersionT &lhs, const OpVersionT &rhs);
bool operator!=(const OpVersionT &lhs, const OpVersionT &rhs);
bool operator==(const OpVersionMapT &lhs, const OpVersionMapT &rhs);
bool operator!=(const OpVersionMapT &lhs, const OpVersionMapT &rhs);
namespace OpVersionMap_ {

bool operator==(const OpVersionPairT &lhs, const OpVersionPairT &rhs);
bool operator!=(const OpVersionPairT &lhs, const OpVersionPairT &rhs);
}  // namespace OpVersionMap_

bool operator==(const ProgramDescT &lhs, const ProgramDescT &rhs);
bool operator!=(const ProgramDescT &lhs, const ProgramDescT &rhs);

inline const flatbuffers::TypeTable *VersionTypeTable();

inline const flatbuffers::TypeTable *OpDescTypeTable();

namespace OpDesc_ {

inline const flatbuffers::TypeTable *AttrTypeTable();

inline const flatbuffers::TypeTable *VarTypeTable();

}  // namespace OpDesc_

inline const flatbuffers::TypeTable *VarTypeTypeTable();

namespace VarType_ {

inline const flatbuffers::TypeTable *TensorDescTypeTable();

inline const flatbuffers::TypeTable *LoDTensorDescTypeTable();

inline const flatbuffers::TypeTable *LoDTensorArrayDescTypeTable();

inline const flatbuffers::TypeTable *ReaderDescTypeTable();

inline const flatbuffers::TypeTable *TupleTypeTable();

}  // namespace VarType_

inline const flatbuffers::TypeTable *VarDescTypeTable();

inline const flatbuffers::TypeTable *BlockDescTypeTable();

inline const flatbuffers::TypeTable *OpVersionTypeTable();

inline const flatbuffers::TypeTable *OpVersionMapTypeTable();

namespace OpVersionMap_ {

inline const flatbuffers::TypeTable *OpVersionPairTypeTable();

}  // namespace OpVersionMap_

inline const flatbuffers::TypeTable *ProgramDescTypeTable();

enum AttrType {
  AttrType_INT = 0,
  AttrType_FLOAT = 1,
  AttrType_STRING = 2,
  AttrType_INTS = 3,
  AttrType_FLOATS = 4,
  AttrType_STRINGS = 5,
  AttrType_BOOLEAN = 6,
  AttrType_BOOLEANS = 7,
  AttrType_BLOCK = 8,
  AttrType_LONG = 9,
  AttrType_BLOCKS = 10,
  AttrType_LONGS = 11,
  AttrType_MIN = AttrType_INT,
  AttrType_MAX = AttrType_LONGS
};

inline const AttrType (&EnumValuesAttrType())[12] {
  static const AttrType values[] = {
    AttrType_INT,
    AttrType_FLOAT,
    AttrType_STRING,
    AttrType_INTS,
    AttrType_FLOATS,
    AttrType_STRINGS,
    AttrType_BOOLEAN,
    AttrType_BOOLEANS,
    AttrType_BLOCK,
    AttrType_LONG,
    AttrType_BLOCKS,
    AttrType_LONGS
  };
  return values;
}

inline const char * const *EnumNamesAttrType() {
  static const char * const names[13] = {
    "INT",
    "FLOAT",
    "STRING",
    "INTS",
    "FLOATS",
    "STRINGS",
    "BOOLEAN",
    "BOOLEANS",
    "BLOCK",
    "LONG",
    "BLOCKS",
    "LONGS",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttrType(AttrType e) {
  if (flatbuffers::IsOutRange(e, AttrType_INT, AttrType_LONGS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttrType()[index];
}

namespace VarType_ {

enum Type {
  Type_BOOL = 0,
  Type_INT16 = 1,
  Type_INT32 = 2,
  Type_INT64 = 3,
  Type_FP16 = 4,
  Type_FP32 = 5,
  Type_FP64 = 6,
  Type_LOD_TENSOR = 7,
  Type_SELECTED_ROWS = 8,
  Type_FEED_MINIBATCH = 9,
  Type_FETCH_LIST = 10,
  Type_STEP_SCOPES = 11,
  Type_LOD_RANK_TABLE = 12,
  Type_LOD_TENSOR_ARRAY = 13,
  Type_PLACE_LIST = 14,
  Type_READER = 15,
  Type_RAW = 17,
  Type_TUPLE = 18,
  Type_SIZE_T = 19,
  Type_UINT8 = 20,
  Type_INT8 = 21,
  Type_MIN = Type_BOOL,
  Type_MAX = Type_INT8
};

inline const Type (&EnumValuesType())[21] {
  static const Type values[] = {
    Type_BOOL,
    Type_INT16,
    Type_INT32,
    Type_INT64,
    Type_FP16,
    Type_FP32,
    Type_FP64,
    Type_LOD_TENSOR,
    Type_SELECTED_ROWS,
    Type_FEED_MINIBATCH,
    Type_FETCH_LIST,
    Type_STEP_SCOPES,
    Type_LOD_RANK_TABLE,
    Type_LOD_TENSOR_ARRAY,
    Type_PLACE_LIST,
    Type_READER,
    Type_RAW,
    Type_TUPLE,
    Type_SIZE_T,
    Type_UINT8,
    Type_INT8
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[23] = {
    "BOOL",
    "INT16",
    "INT32",
    "INT64",
    "FP16",
    "FP32",
    "FP64",
    "LOD_TENSOR",
    "SELECTED_ROWS",
    "FEED_MINIBATCH",
    "FETCH_LIST",
    "STEP_SCOPES",
    "LOD_RANK_TABLE",
    "LOD_TENSOR_ARRAY",
    "PLACE_LIST",
    "READER",
    "",
    "RAW",
    "TUPLE",
    "SIZE_T",
    "UINT8",
    "INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_BOOL, Type_INT8)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

}  // namespace VarType_

namespace CompatibleInfo_ {

enum Type {
  Type_COMPATIBLE = 0,
  Type_DEFINITELY_NOT = 1,
  Type_POSSIBLE = 2,
  Type_BUG_FIX = 3,
  Type_PRECISION_CHANGE = 4,
  Type_MIN = Type_COMPATIBLE,
  Type_MAX = Type_PRECISION_CHANGE
};

inline const Type (&EnumValuesType())[5] {
  static const Type values[] = {
    Type_COMPATIBLE,
    Type_DEFINITELY_NOT,
    Type_POSSIBLE,
    Type_BUG_FIX,
    Type_PRECISION_CHANGE
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[6] = {
    "COMPATIBLE",
    "DEFINITELY_NOT",
    "POSSIBLE",
    "BUG_FIX",
    "PRECISION_CHANGE",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_COMPATIBLE, Type_PRECISION_CHANGE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

}  // namespace CompatibleInfo_

struct VersionT : public flatbuffers::NativeTable {
  typedef Version TableType;
  int64_t version;
  VersionT()
      : version(0) {
  }
};

inline bool operator==(const VersionT &lhs, const VersionT &rhs) {
  return
      (lhs.version == rhs.version);
}

inline bool operator!=(const VersionT &lhs, const VersionT &rhs) {
    return !(lhs == rhs);
}


struct Version FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VersionT NativeTableType;
  typedef VersionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VersionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4
  };
  int64_t version() const {
    return GetField<int64_t>(VT_VERSION, 0);
  }
  bool mutate_version(int64_t _version) {
    return SetField<int64_t>(VT_VERSION, _version, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
  VersionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VersionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Version> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VersionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VersionBuilder {
  typedef Version Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(int64_t version) {
    fbb_.AddElement<int64_t>(Version::VT_VERSION, version, 0);
  }
  explicit VersionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VersionBuilder &operator=(const VersionBuilder &);
  flatbuffers::Offset<Version> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Version>(end);
    return o;
  }
};

inline flatbuffers::Offset<Version> CreateVersion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t version = 0) {
  VersionBuilder builder_(_fbb);
  builder_.add_version(version);
  return builder_.Finish();
}

flatbuffers::Offset<Version> CreateVersion(flatbuffers::FlatBufferBuilder &_fbb, const VersionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OpDescT : public flatbuffers::NativeTable {
  typedef OpDesc TableType;
  std::string type;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT>> inputs;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT>> outputs;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::AttrT>> attrs;
  bool is_target;
  OpDescT()
      : is_target(false) {
  }
};

inline bool operator==(const OpDescT &lhs, const OpDescT &rhs) {
  return
      (lhs.type == rhs.type) &&
      (lhs.inputs == rhs.inputs) &&
      (lhs.outputs == rhs.outputs) &&
      (lhs.attrs == rhs.attrs) &&
      (lhs.is_target == rhs.is_target);
}

inline bool operator!=(const OpDescT &lhs, const OpDescT &rhs) {
    return !(lhs == rhs);
}


struct OpDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpDescT NativeTableType;
  typedef OpDescBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OpDescTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_ATTRS = 10,
    VT_IS_TARGET = 12
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  flatbuffers::String *mutable_type() {
    return GetPointer<flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *>(VT_INPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *mutable_inputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *>(VT_OUTPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *mutable_outputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>> *attrs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>> *>(VT_ATTRS);
  }
  flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>> *mutable_attrs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>> *>(VT_ATTRS);
  }
  bool is_target() const {
    return GetField<uint8_t>(VT_IS_TARGET, 0) != 0;
  }
  bool mutate_is_target(bool _is_target) {
    return SetField<uint8_t>(VT_IS_TARGET, static_cast<uint8_t>(_is_target), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_ATTRS) &&
           verifier.VerifyVector(attrs()) &&
           verifier.VerifyVectorOfTables(attrs()) &&
           VerifyField<uint8_t>(verifier, VT_IS_TARGET) &&
           verifier.EndTable();
  }
  OpDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OpDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OpDescBuilder {
  typedef OpDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(OpDesc::VT_TYPE, type);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>>> inputs) {
    fbb_.AddOffset(OpDesc::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>>> outputs) {
    fbb_.AddOffset(OpDesc::VT_OUTPUTS, outputs);
  }
  void add_attrs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>>> attrs) {
    fbb_.AddOffset(OpDesc::VT_ATTRS, attrs);
  }
  void add_is_target(bool is_target) {
    fbb_.AddElement<uint8_t>(OpDesc::VT_IS_TARGET, static_cast<uint8_t>(is_target), 0);
  }
  explicit OpDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OpDescBuilder &operator=(const OpDescBuilder &);
  flatbuffers::Offset<OpDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpDesc>(end);
    fbb_.Required(o, OpDesc::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<OpDesc> CreateOpDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>>> attrs = 0,
    bool is_target = false) {
  OpDescBuilder builder_(_fbb);
  builder_.add_attrs(attrs);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_type(type);
  builder_.add_is_target(is_target);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpDesc> CreateOpDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *inputs = nullptr,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *outputs = nullptr,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>> *attrs = nullptr,
    bool is_target = false) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::proto::OpDesc_::Var>(inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::proto::OpDesc_::Var>(outputs) : 0;
  auto attrs__ = attrs ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::proto::OpDesc_::Attr>(attrs) : 0;
  return paddle::lite::fbs::proto::CreateOpDesc(
      _fbb,
      type__,
      inputs__,
      outputs__,
      attrs__,
      is_target);
}

flatbuffers::Offset<OpDesc> CreateOpDesc(flatbuffers::FlatBufferBuilder &_fbb, const OpDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace OpDesc_ {

struct AttrT : public flatbuffers::NativeTable {
  typedef Attr TableType;
  std::string name;
  paddle::lite::fbs::proto::AttrType type;
  int32_t i;
  float f;
  std::string s;
  std::vector<int32_t> ints;
  std::vector<float> floats;
  std::vector<std::string> strings;
  bool b;
  std::vector<bool> bools;
  int32_t block_idx;
  int64_t l;
  std::vector<int32_t> blocks_idx;
  std::vector<int64_t> longs;
  AttrT()
      : type(paddle::lite::fbs::proto::AttrType_INT),
        i(0),
        f(0.0f),
        b(false),
        block_idx(0),
        l(0) {
  }
};

inline bool operator==(const AttrT &lhs, const AttrT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.type == rhs.type) &&
      (lhs.i == rhs.i) &&
      (lhs.f == rhs.f) &&
      (lhs.s == rhs.s) &&
      (lhs.ints == rhs.ints) &&
      (lhs.floats == rhs.floats) &&
      (lhs.strings == rhs.strings) &&
      (lhs.b == rhs.b) &&
      (lhs.bools == rhs.bools) &&
      (lhs.block_idx == rhs.block_idx) &&
      (lhs.l == rhs.l) &&
      (lhs.blocks_idx == rhs.blocks_idx) &&
      (lhs.longs == rhs.longs);
}

inline bool operator!=(const AttrT &lhs, const AttrT &rhs) {
    return !(lhs == rhs);
}


struct Attr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttrT NativeTableType;
  typedef AttrBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AttrTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_I = 8,
    VT_F = 10,
    VT_S = 12,
    VT_INTS = 14,
    VT_FLOATS = 16,
    VT_STRINGS = 18,
    VT_B = 20,
    VT_BOOLS = 22,
    VT_BLOCK_IDX = 24,
    VT_L = 26,
    VT_BLOCKS_IDX = 28,
    VT_LONGS = 30
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Attr *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  paddle::lite::fbs::proto::AttrType type() const {
    return static_cast<paddle::lite::fbs::proto::AttrType>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool mutate_type(paddle::lite::fbs::proto::AttrType _type) {
    return SetField<int32_t>(VT_TYPE, static_cast<int32_t>(_type), 0);
  }
  int32_t i() const {
    return GetField<int32_t>(VT_I, 0);
  }
  bool mutate_i(int32_t _i) {
    return SetField<int32_t>(VT_I, _i, 0);
  }
  float f() const {
    return GetField<float>(VT_F, 0.0f);
  }
  bool mutate_f(float _f) {
    return SetField<float>(VT_F, _f, 0.0f);
  }
  const flatbuffers::String *s() const {
    return GetPointer<const flatbuffers::String *>(VT_S);
  }
  flatbuffers::String *mutable_s() {
    return GetPointer<flatbuffers::String *>(VT_S);
  }
  const flatbuffers::Vector<int32_t> *ints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INTS);
  }
  flatbuffers::Vector<int32_t> *mutable_ints() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_INTS);
  }
  const flatbuffers::Vector<float> *floats() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  flatbuffers::Vector<float> *mutable_floats() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *strings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRINGS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_strings() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRINGS);
  }
  bool b() const {
    return GetField<uint8_t>(VT_B, 0) != 0;
  }
  bool mutate_b(bool _b) {
    return SetField<uint8_t>(VT_B, static_cast<uint8_t>(_b), 0);
  }
  const flatbuffers::Vector<uint8_t> *bools() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BOOLS);
  }
  flatbuffers::Vector<uint8_t> *mutable_bools() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_BOOLS);
  }
  int32_t block_idx() const {
    return GetField<int32_t>(VT_BLOCK_IDX, 0);
  }
  bool mutate_block_idx(int32_t _block_idx) {
    return SetField<int32_t>(VT_BLOCK_IDX, _block_idx, 0);
  }
  int64_t l() const {
    return GetField<int64_t>(VT_L, 0);
  }
  bool mutate_l(int64_t _l) {
    return SetField<int64_t>(VT_L, _l, 0);
  }
  const flatbuffers::Vector<int32_t> *blocks_idx() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKS_IDX);
  }
  flatbuffers::Vector<int32_t> *mutable_blocks_idx() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_BLOCKS_IDX);
  }
  const flatbuffers::Vector<int64_t> *longs() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_LONGS);
  }
  flatbuffers::Vector<int64_t> *mutable_longs() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_LONGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_I) &&
           VerifyField<float>(verifier, VT_F) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           VerifyOffset(verifier, VT_INTS) &&
           verifier.VerifyVector(ints()) &&
           VerifyOffset(verifier, VT_FLOATS) &&
           verifier.VerifyVector(floats()) &&
           VerifyOffset(verifier, VT_STRINGS) &&
           verifier.VerifyVector(strings()) &&
           verifier.VerifyVectorOfStrings(strings()) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           VerifyOffset(verifier, VT_BOOLS) &&
           verifier.VerifyVector(bools()) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_IDX) &&
           VerifyField<int64_t>(verifier, VT_L) &&
           VerifyOffset(verifier, VT_BLOCKS_IDX) &&
           verifier.VerifyVector(blocks_idx()) &&
           VerifyOffset(verifier, VT_LONGS) &&
           verifier.VerifyVector(longs()) &&
           verifier.EndTable();
  }
  AttrT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttrT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Attr> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttrT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttrBuilder {
  typedef Attr Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Attr::VT_NAME, name);
  }
  void add_type(paddle::lite::fbs::proto::AttrType type) {
    fbb_.AddElement<int32_t>(Attr::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_i(int32_t i) {
    fbb_.AddElement<int32_t>(Attr::VT_I, i, 0);
  }
  void add_f(float f) {
    fbb_.AddElement<float>(Attr::VT_F, f, 0.0f);
  }
  void add_s(flatbuffers::Offset<flatbuffers::String> s) {
    fbb_.AddOffset(Attr::VT_S, s);
  }
  void add_ints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ints) {
    fbb_.AddOffset(Attr::VT_INTS, ints);
  }
  void add_floats(flatbuffers::Offset<flatbuffers::Vector<float>> floats) {
    fbb_.AddOffset(Attr::VT_FLOATS, floats);
  }
  void add_strings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> strings) {
    fbb_.AddOffset(Attr::VT_STRINGS, strings);
  }
  void add_b(bool b) {
    fbb_.AddElement<uint8_t>(Attr::VT_B, static_cast<uint8_t>(b), 0);
  }
  void add_bools(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bools) {
    fbb_.AddOffset(Attr::VT_BOOLS, bools);
  }
  void add_block_idx(int32_t block_idx) {
    fbb_.AddElement<int32_t>(Attr::VT_BLOCK_IDX, block_idx, 0);
  }
  void add_l(int64_t l) {
    fbb_.AddElement<int64_t>(Attr::VT_L, l, 0);
  }
  void add_blocks_idx(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blocks_idx) {
    fbb_.AddOffset(Attr::VT_BLOCKS_IDX, blocks_idx);
  }
  void add_longs(flatbuffers::Offset<flatbuffers::Vector<int64_t>> longs) {
    fbb_.AddOffset(Attr::VT_LONGS, longs);
  }
  explicit AttrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttrBuilder &operator=(const AttrBuilder &);
  flatbuffers::Offset<Attr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attr>(end);
    fbb_.Required(o, Attr::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Attr> CreateAttr(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    paddle::lite::fbs::proto::AttrType type = paddle::lite::fbs::proto::AttrType_INT,
    int32_t i = 0,
    float f = 0.0f,
    flatbuffers::Offset<flatbuffers::String> s = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ints = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> floats = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> strings = 0,
    bool b = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bools = 0,
    int32_t block_idx = 0,
    int64_t l = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blocks_idx = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> longs = 0) {
  AttrBuilder builder_(_fbb);
  builder_.add_l(l);
  builder_.add_longs(longs);
  builder_.add_blocks_idx(blocks_idx);
  builder_.add_block_idx(block_idx);
  builder_.add_bools(bools);
  builder_.add_strings(strings);
  builder_.add_floats(floats);
  builder_.add_ints(ints);
  builder_.add_s(s);
  builder_.add_f(f);
  builder_.add_i(i);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_b(b);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attr> CreateAttrDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    paddle::lite::fbs::proto::AttrType type = paddle::lite::fbs::proto::AttrType_INT,
    int32_t i = 0,
    float f = 0.0f,
    const char *s = nullptr,
    const std::vector<int32_t> *ints = nullptr,
    const std::vector<float> *floats = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *strings = nullptr,
    bool b = false,
    const std::vector<uint8_t> *bools = nullptr,
    int32_t block_idx = 0,
    int64_t l = 0,
    const std::vector<int32_t> *blocks_idx = nullptr,
    const std::vector<int64_t> *longs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto s__ = s ? _fbb.CreateString(s) : 0;
  auto ints__ = ints ? _fbb.CreateVector<int32_t>(*ints) : 0;
  auto floats__ = floats ? _fbb.CreateVector<float>(*floats) : 0;
  auto strings__ = strings ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*strings) : 0;
  auto bools__ = bools ? _fbb.CreateVector<uint8_t>(*bools) : 0;
  auto blocks_idx__ = blocks_idx ? _fbb.CreateVector<int32_t>(*blocks_idx) : 0;
  auto longs__ = longs ? _fbb.CreateVector<int64_t>(*longs) : 0;
  return paddle::lite::fbs::proto::OpDesc_::CreateAttr(
      _fbb,
      name__,
      type,
      i,
      f,
      s__,
      ints__,
      floats__,
      strings__,
      b,
      bools__,
      block_idx,
      l,
      blocks_idx__,
      longs__);
}

flatbuffers::Offset<Attr> CreateAttr(flatbuffers::FlatBufferBuilder &_fbb, const AttrT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VarT : public flatbuffers::NativeTable {
  typedef Var TableType;
  std::string parameter;
  std::vector<std::string> arguments;
  VarT() {
  }
};

inline bool operator==(const VarT &lhs, const VarT &rhs) {
  return
      (lhs.parameter == rhs.parameter) &&
      (lhs.arguments == rhs.arguments);
}

inline bool operator!=(const VarT &lhs, const VarT &rhs) {
    return !(lhs == rhs);
}


struct Var FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VarT NativeTableType;
  typedef VarBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VarTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER = 4,
    VT_ARGUMENTS = 6
  };
  const flatbuffers::String *parameter() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMETER);
  }
  flatbuffers::String *mutable_parameter() {
    return GetPointer<flatbuffers::String *>(VT_PARAMETER);
  }
  bool KeyCompareLessThan(const Var *o) const {
    return *parameter() < *o->parameter();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(parameter()->c_str(), val);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARGUMENTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_arguments() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARGUMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PARAMETER) &&
           verifier.VerifyString(parameter()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfStrings(arguments()) &&
           verifier.EndTable();
  }
  VarT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VarT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Var> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VarBuilder {
  typedef Var Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_parameter(flatbuffers::Offset<flatbuffers::String> parameter) {
    fbb_.AddOffset(Var::VT_PARAMETER, parameter);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> arguments) {
    fbb_.AddOffset(Var::VT_ARGUMENTS, arguments);
  }
  explicit VarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VarBuilder &operator=(const VarBuilder &);
  flatbuffers::Offset<Var> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Var>(end);
    fbb_.Required(o, Var::VT_PARAMETER);
    return o;
  }
};

inline flatbuffers::Offset<Var> CreateVar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> parameter = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> arguments = 0) {
  VarBuilder builder_(_fbb);
  builder_.add_arguments(arguments);
  builder_.add_parameter(parameter);
  return builder_.Finish();
}

inline flatbuffers::Offset<Var> CreateVarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *parameter = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *arguments = nullptr) {
  auto parameter__ = parameter ? _fbb.CreateString(parameter) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*arguments) : 0;
  return paddle::lite::fbs::proto::OpDesc_::CreateVar(
      _fbb,
      parameter__,
      arguments__);
}

flatbuffers::Offset<Var> CreateVar(flatbuffers::FlatBufferBuilder &_fbb, const VarT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace OpDesc_

struct VarTypeT : public flatbuffers::NativeTable {
  typedef VarType TableType;
  paddle::lite::fbs::proto::VarType_::Type type;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT> selected_rows;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT> lod_tensor;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDescT> tensor_array;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::ReaderDescT> reader;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TupleT> tuple;
  VarTypeT()
      : type(paddle::lite::fbs::proto::VarType_::Type_BOOL) {
  }
};

inline bool operator==(const VarTypeT &lhs, const VarTypeT &rhs) {
  return
      (lhs.type == rhs.type) &&
      (lhs.selected_rows == rhs.selected_rows) &&
      (lhs.lod_tensor == rhs.lod_tensor) &&
      (lhs.tensor_array == rhs.tensor_array) &&
      (lhs.reader == rhs.reader) &&
      (lhs.tuple == rhs.tuple);
}

inline bool operator!=(const VarTypeT &lhs, const VarTypeT &rhs) {
    return !(lhs == rhs);
}


struct VarType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VarTypeT NativeTableType;
  typedef VarTypeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VarTypeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_SELECTED_ROWS = 6,
    VT_LOD_TENSOR = 8,
    VT_TENSOR_ARRAY = 10,
    VT_READER = 12,
    VT_TUPLE = 14
  };
  paddle::lite::fbs::proto::VarType_::Type type() const {
    return static_cast<paddle::lite::fbs::proto::VarType_::Type>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool mutate_type(paddle::lite::fbs::proto::VarType_::Type _type) {
    return SetField<int32_t>(VT_TYPE, static_cast<int32_t>(_type), 0);
  }
  const paddle::lite::fbs::proto::VarType_::TensorDesc *selected_rows() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::TensorDesc *>(VT_SELECTED_ROWS);
  }
  paddle::lite::fbs::proto::VarType_::TensorDesc *mutable_selected_rows() {
    return GetPointer<paddle::lite::fbs::proto::VarType_::TensorDesc *>(VT_SELECTED_ROWS);
  }
  const paddle::lite::fbs::proto::VarType_::LoDTensorDesc *lod_tensor() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::LoDTensorDesc *>(VT_LOD_TENSOR);
  }
  paddle::lite::fbs::proto::VarType_::LoDTensorDesc *mutable_lod_tensor() {
    return GetPointer<paddle::lite::fbs::proto::VarType_::LoDTensorDesc *>(VT_LOD_TENSOR);
  }
  const paddle::lite::fbs::proto::VarType_::LoDTensorArrayDesc *tensor_array() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::LoDTensorArrayDesc *>(VT_TENSOR_ARRAY);
  }
  paddle::lite::fbs::proto::VarType_::LoDTensorArrayDesc *mutable_tensor_array() {
    return GetPointer<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDesc *>(VT_TENSOR_ARRAY);
  }
  const paddle::lite::fbs::proto::VarType_::ReaderDesc *reader() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::ReaderDesc *>(VT_READER);
  }
  paddle::lite::fbs::proto::VarType_::ReaderDesc *mutable_reader() {
    return GetPointer<paddle::lite::fbs::proto::VarType_::ReaderDesc *>(VT_READER);
  }
  const paddle::lite::fbs::proto::VarType_::Tuple *tuple() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::Tuple *>(VT_TUPLE);
  }
  paddle::lite::fbs::proto::VarType_::Tuple *mutable_tuple() {
    return GetPointer<paddle::lite::fbs::proto::VarType_::Tuple *>(VT_TUPLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_SELECTED_ROWS) &&
           verifier.VerifyTable(selected_rows()) &&
           VerifyOffset(verifier, VT_LOD_TENSOR) &&
           verifier.VerifyTable(lod_tensor()) &&
           VerifyOffset(verifier, VT_TENSOR_ARRAY) &&
           verifier.VerifyTable(tensor_array()) &&
           VerifyOffset(verifier, VT_READER) &&
           verifier.VerifyTable(reader()) &&
           VerifyOffset(verifier, VT_TUPLE) &&
           verifier.VerifyTable(tuple()) &&
           verifier.EndTable();
  }
  VarTypeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VarTypeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VarType> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarTypeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VarTypeBuilder {
  typedef VarType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(paddle::lite::fbs::proto::VarType_::Type type) {
    fbb_.AddElement<int32_t>(VarType::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_selected_rows(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> selected_rows) {
    fbb_.AddOffset(VarType::VT_SELECTED_ROWS, selected_rows);
  }
  void add_lod_tensor(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc> lod_tensor) {
    fbb_.AddOffset(VarType::VT_LOD_TENSOR, lod_tensor);
  }
  void add_tensor_array(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDesc> tensor_array) {
    fbb_.AddOffset(VarType::VT_TENSOR_ARRAY, tensor_array);
  }
  void add_reader(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::ReaderDesc> reader) {
    fbb_.AddOffset(VarType::VT_READER, reader);
  }
  void add_tuple(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::Tuple> tuple) {
    fbb_.AddOffset(VarType::VT_TUPLE, tuple);
  }
  explicit VarTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VarTypeBuilder &operator=(const VarTypeBuilder &);
  flatbuffers::Offset<VarType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarType>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarType> CreateVarType(
    flatbuffers::FlatBufferBuilder &_fbb,
    paddle::lite::fbs::proto::VarType_::Type type = paddle::lite::fbs::proto::VarType_::Type_BOOL,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> selected_rows = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc> lod_tensor = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDesc> tensor_array = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::ReaderDesc> reader = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::Tuple> tuple = 0) {
  VarTypeBuilder builder_(_fbb);
  builder_.add_tuple(tuple);
  builder_.add_reader(reader);
  builder_.add_tensor_array(tensor_array);
  builder_.add_lod_tensor(lod_tensor);
  builder_.add_selected_rows(selected_rows);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<VarType> CreateVarType(flatbuffers::FlatBufferBuilder &_fbb, const VarTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace VarType_ {

struct TensorDescT : public flatbuffers::NativeTable {
  typedef TensorDesc TableType;
  paddle::lite::fbs::proto::VarType_::Type data_type;
  std::vector<int64_t> dims;
  TensorDescT()
      : data_type(paddle::lite::fbs::proto::VarType_::Type_BOOL) {
  }
};

inline bool operator==(const TensorDescT &lhs, const TensorDescT &rhs) {
  return
      (lhs.data_type == rhs.data_type) &&
      (lhs.dims == rhs.dims);
}

inline bool operator!=(const TensorDescT &lhs, const TensorDescT &rhs) {
    return !(lhs == rhs);
}


struct TensorDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorDescT NativeTableType;
  typedef TensorDescBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorDescTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DIMS = 6
  };
  paddle::lite::fbs::proto::VarType_::Type data_type() const {
    return static_cast<paddle::lite::fbs::proto::VarType_::Type>(GetField<int32_t>(VT_DATA_TYPE, 0));
  }
  bool mutate_data_type(paddle::lite::fbs::proto::VarType_::Type _data_type) {
    return SetField<int32_t>(VT_DATA_TYPE, static_cast<int32_t>(_data_type), 0);
  }
  const flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  flatbuffers::Vector<int64_t> *mutable_dims() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  TensorDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorDescBuilder {
  typedef TensorDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(paddle::lite::fbs::proto::VarType_::Type data_type) {
    fbb_.AddElement<int32_t>(TensorDesc::VT_DATA_TYPE, static_cast<int32_t>(data_type), 0);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(TensorDesc::VT_DIMS, dims);
  }
  explicit TensorDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorDescBuilder &operator=(const TensorDescBuilder &);
  flatbuffers::Offset<TensorDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorDesc> CreateTensorDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    paddle::lite::fbs::proto::VarType_::Type data_type = paddle::lite::fbs::proto::VarType_::Type_BOOL,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims = 0) {
  TensorDescBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorDesc> CreateTensorDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    paddle::lite::fbs::proto::VarType_::Type data_type = paddle::lite::fbs::proto::VarType_::Type_BOOL,
    const std::vector<int64_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  return paddle::lite::fbs::proto::VarType_::CreateTensorDesc(
      _fbb,
      data_type,
      dims__);
}

flatbuffers::Offset<TensorDesc> CreateTensorDesc(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoDTensorDescT : public flatbuffers::NativeTable {
  typedef LoDTensorDesc TableType;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT> tensor;
  int32_t lod_level;
  LoDTensorDescT()
      : lod_level(0) {
  }
};

inline bool operator==(const LoDTensorDescT &lhs, const LoDTensorDescT &rhs) {
  return
      (lhs.tensor == rhs.tensor) &&
      (lhs.lod_level == rhs.lod_level);
}

inline bool operator!=(const LoDTensorDescT &lhs, const LoDTensorDescT &rhs) {
    return !(lhs == rhs);
}


struct LoDTensorDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoDTensorDescT NativeTableType;
  typedef LoDTensorDescBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LoDTensorDescTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR = 4,
    VT_LOD_LEVEL = 6
  };
  const paddle::lite::fbs::proto::VarType_::TensorDesc *tensor() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::TensorDesc *>(VT_TENSOR);
  }
  paddle::lite::fbs::proto::VarType_::TensorDesc *mutable_tensor() {
    return GetPointer<paddle::lite::fbs::proto::VarType_::TensorDesc *>(VT_TENSOR);
  }
  int32_t lod_level() const {
    return GetField<int32_t>(VT_LOD_LEVEL, 0);
  }
  bool mutate_lod_level(int32_t _lod_level) {
    return SetField<int32_t>(VT_LOD_LEVEL, _lod_level, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TENSOR) &&
           verifier.VerifyTable(tensor()) &&
           VerifyField<int32_t>(verifier, VT_LOD_LEVEL) &&
           verifier.EndTable();
  }
  LoDTensorDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoDTensorDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoDTensorDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoDTensorDescBuilder {
  typedef LoDTensorDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensor(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> tensor) {
    fbb_.AddOffset(LoDTensorDesc::VT_TENSOR, tensor);
  }
  void add_lod_level(int32_t lod_level) {
    fbb_.AddElement<int32_t>(LoDTensorDesc::VT_LOD_LEVEL, lod_level, 0);
  }
  explicit LoDTensorDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoDTensorDescBuilder &operator=(const LoDTensorDescBuilder &);
  flatbuffers::Offset<LoDTensorDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoDTensorDesc>(end);
    fbb_.Required(o, LoDTensorDesc::VT_TENSOR);
    return o;
  }
};

inline flatbuffers::Offset<LoDTensorDesc> CreateLoDTensorDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> tensor = 0,
    int32_t lod_level = 0) {
  LoDTensorDescBuilder builder_(_fbb);
  builder_.add_lod_level(lod_level);
  builder_.add_tensor(tensor);
  return builder_.Finish();
}

flatbuffers::Offset<LoDTensorDesc> CreateLoDTensorDesc(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoDTensorArrayDescT : public flatbuffers::NativeTable {
  typedef LoDTensorArrayDesc TableType;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT> tensor;
  int32_t lod_level;
  LoDTensorArrayDescT()
      : lod_level(0) {
  }
};

inline bool operator==(const LoDTensorArrayDescT &lhs, const LoDTensorArrayDescT &rhs) {
  return
      (lhs.tensor == rhs.tensor) &&
      (lhs.lod_level == rhs.lod_level);
}

inline bool operator!=(const LoDTensorArrayDescT &lhs, const LoDTensorArrayDescT &rhs) {
    return !(lhs == rhs);
}


struct LoDTensorArrayDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoDTensorArrayDescT NativeTableType;
  typedef LoDTensorArrayDescBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LoDTensorArrayDescTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR = 4,
    VT_LOD_LEVEL = 6
  };
  const paddle::lite::fbs::proto::VarType_::TensorDesc *tensor() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::TensorDesc *>(VT_TENSOR);
  }
  paddle::lite::fbs::proto::VarType_::TensorDesc *mutable_tensor() {
    return GetPointer<paddle::lite::fbs::proto::VarType_::TensorDesc *>(VT_TENSOR);
  }
  int32_t lod_level() const {
    return GetField<int32_t>(VT_LOD_LEVEL, 0);
  }
  bool mutate_lod_level(int32_t _lod_level) {
    return SetField<int32_t>(VT_LOD_LEVEL, _lod_level, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TENSOR) &&
           verifier.VerifyTable(tensor()) &&
           VerifyField<int32_t>(verifier, VT_LOD_LEVEL) &&
           verifier.EndTable();
  }
  LoDTensorArrayDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoDTensorArrayDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoDTensorArrayDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorArrayDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoDTensorArrayDescBuilder {
  typedef LoDTensorArrayDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensor(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> tensor) {
    fbb_.AddOffset(LoDTensorArrayDesc::VT_TENSOR, tensor);
  }
  void add_lod_level(int32_t lod_level) {
    fbb_.AddElement<int32_t>(LoDTensorArrayDesc::VT_LOD_LEVEL, lod_level, 0);
  }
  explicit LoDTensorArrayDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoDTensorArrayDescBuilder &operator=(const LoDTensorArrayDescBuilder &);
  flatbuffers::Offset<LoDTensorArrayDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoDTensorArrayDesc>(end);
    fbb_.Required(o, LoDTensorArrayDesc::VT_TENSOR);
    return o;
  }
};

inline flatbuffers::Offset<LoDTensorArrayDesc> CreateLoDTensorArrayDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> tensor = 0,
    int32_t lod_level = 0) {
  LoDTensorArrayDescBuilder builder_(_fbb);
  builder_.add_lod_level(lod_level);
  builder_.add_tensor(tensor);
  return builder_.Finish();
}

flatbuffers::Offset<LoDTensorArrayDesc> CreateLoDTensorArrayDesc(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorArrayDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReaderDescT : public flatbuffers::NativeTable {
  typedef ReaderDesc TableType;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT>> lod_tensor;
  ReaderDescT() {
  }
};

inline bool operator==(const ReaderDescT &lhs, const ReaderDescT &rhs) {
  return
      (lhs.lod_tensor == rhs.lod_tensor);
}

inline bool operator!=(const ReaderDescT &lhs, const ReaderDescT &rhs) {
    return !(lhs == rhs);
}


struct ReaderDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReaderDescT NativeTableType;
  typedef ReaderDescBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReaderDescTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOD_TENSOR = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>> *lod_tensor() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>> *>(VT_LOD_TENSOR);
  }
  flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>> *mutable_lod_tensor() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>> *>(VT_LOD_TENSOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOD_TENSOR) &&
           verifier.VerifyVector(lod_tensor()) &&
           verifier.VerifyVectorOfTables(lod_tensor()) &&
           verifier.EndTable();
  }
  ReaderDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReaderDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReaderDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReaderDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReaderDescBuilder {
  typedef ReaderDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lod_tensor(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>>> lod_tensor) {
    fbb_.AddOffset(ReaderDesc::VT_LOD_TENSOR, lod_tensor);
  }
  explicit ReaderDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReaderDescBuilder &operator=(const ReaderDescBuilder &);
  flatbuffers::Offset<ReaderDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReaderDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReaderDesc> CreateReaderDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>>> lod_tensor = 0) {
  ReaderDescBuilder builder_(_fbb);
  builder_.add_lod_tensor(lod_tensor);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReaderDesc> CreateReaderDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>> *lod_tensor = nullptr) {
  auto lod_tensor__ = lod_tensor ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>>(*lod_tensor) : 0;
  return paddle::lite::fbs::proto::VarType_::CreateReaderDesc(
      _fbb,
      lod_tensor__);
}

flatbuffers::Offset<ReaderDesc> CreateReaderDesc(flatbuffers::FlatBufferBuilder &_fbb, const ReaderDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TupleT : public flatbuffers::NativeTable {
  typedef Tuple TableType;
  std::vector<paddle::lite::fbs::proto::VarType_::Type> element_type;
  TupleT() {
  }
};

inline bool operator==(const TupleT &lhs, const TupleT &rhs) {
  return
      (lhs.element_type == rhs.element_type);
}

inline bool operator!=(const TupleT &lhs, const TupleT &rhs) {
    return !(lhs == rhs);
}


struct Tuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TupleT NativeTableType;
  typedef TupleBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TupleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_TYPE = 4
  };
  const flatbuffers::Vector<int32_t> *element_type() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ELEMENT_TYPE);
  }
  flatbuffers::Vector<int32_t> *mutable_element_type() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ELEMENT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEMENT_TYPE) &&
           verifier.VerifyVector(element_type()) &&
           verifier.EndTable();
  }
  TupleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TupleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Tuple> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TupleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TupleBuilder {
  typedef Tuple Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element_type(flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_type) {
    fbb_.AddOffset(Tuple::VT_ELEMENT_TYPE, element_type);
  }
  explicit TupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TupleBuilder &operator=(const TupleBuilder &);
  flatbuffers::Offset<Tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tuple> CreateTuple(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_type = 0) {
  TupleBuilder builder_(_fbb);
  builder_.add_element_type(element_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tuple> CreateTupleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *element_type = nullptr) {
  auto element_type__ = element_type ? _fbb.CreateVector<int32_t>(*element_type) : 0;
  return paddle::lite::fbs::proto::VarType_::CreateTuple(
      _fbb,
      element_type__);
}

flatbuffers::Offset<Tuple> CreateTuple(flatbuffers::FlatBufferBuilder &_fbb, const TupleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace VarType_

struct VarDescT : public flatbuffers::NativeTable {
  typedef VarDesc TableType;
  std::string name;
  std::unique_ptr<paddle::lite::fbs::proto::VarTypeT> type;
  bool persistable;
  bool need_check_feed;
  VarDescT()
      : persistable(false),
        need_check_feed(false) {
  }
};

inline bool operator==(const VarDescT &lhs, const VarDescT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.type == rhs.type) &&
      (lhs.persistable == rhs.persistable) &&
      (lhs.need_check_feed == rhs.need_check_feed);
}

inline bool operator!=(const VarDescT &lhs, const VarDescT &rhs) {
    return !(lhs == rhs);
}


struct VarDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VarDescT NativeTableType;
  typedef VarDescBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VarDescTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_PERSISTABLE = 8,
    VT_NEED_CHECK_FEED = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const VarDesc *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  const paddle::lite::fbs::proto::VarType *type() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType *>(VT_TYPE);
  }
  paddle::lite::fbs::proto::VarType *mutable_type() {
    return GetPointer<paddle::lite::fbs::proto::VarType *>(VT_TYPE);
  }
  bool persistable() const {
    return GetField<uint8_t>(VT_PERSISTABLE, 0) != 0;
  }
  bool mutate_persistable(bool _persistable) {
    return SetField<uint8_t>(VT_PERSISTABLE, static_cast<uint8_t>(_persistable), 0);
  }
  bool need_check_feed() const {
    return GetField<uint8_t>(VT_NEED_CHECK_FEED, 0) != 0;
  }
  bool mutate_need_check_feed(bool _need_check_feed) {
    return SetField<uint8_t>(VT_NEED_CHECK_FEED, static_cast<uint8_t>(_need_check_feed), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyField<uint8_t>(verifier, VT_PERSISTABLE) &&
           VerifyField<uint8_t>(verifier, VT_NEED_CHECK_FEED) &&
           verifier.EndTable();
  }
  VarDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VarDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VarDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VarDescBuilder {
  typedef VarDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(VarDesc::VT_NAME, name);
  }
  void add_type(flatbuffers::Offset<paddle::lite::fbs::proto::VarType> type) {
    fbb_.AddOffset(VarDesc::VT_TYPE, type);
  }
  void add_persistable(bool persistable) {
    fbb_.AddElement<uint8_t>(VarDesc::VT_PERSISTABLE, static_cast<uint8_t>(persistable), 0);
  }
  void add_need_check_feed(bool need_check_feed) {
    fbb_.AddElement<uint8_t>(VarDesc::VT_NEED_CHECK_FEED, static_cast<uint8_t>(need_check_feed), 0);
  }
  explicit VarDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VarDescBuilder &operator=(const VarDescBuilder &);
  flatbuffers::Offset<VarDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarDesc>(end);
    fbb_.Required(o, VarDesc::VT_NAME);
    fbb_.Required(o, VarDesc::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<VarDesc> CreateVarDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType> type = 0,
    bool persistable = false,
    bool need_check_feed = false) {
  VarDescBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_need_check_feed(need_check_feed);
  builder_.add_persistable(persistable);
  return builder_.Finish();
}

inline flatbuffers::Offset<VarDesc> CreateVarDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType> type = 0,
    bool persistable = false,
    bool need_check_feed = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return paddle::lite::fbs::proto::CreateVarDesc(
      _fbb,
      name__,
      type,
      persistable,
      need_check_feed);
}

flatbuffers::Offset<VarDesc> CreateVarDesc(flatbuffers::FlatBufferBuilder &_fbb, const VarDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlockDescT : public flatbuffers::NativeTable {
  typedef BlockDesc TableType;
  int32_t idx;
  int32_t parent_idx;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::VarDescT>> vars;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::OpDescT>> ops;
  int32_t forward_block_idx;
  BlockDescT()
      : idx(0),
        parent_idx(0),
        forward_block_idx(-1) {
  }
};

inline bool operator==(const BlockDescT &lhs, const BlockDescT &rhs) {
  return
      (lhs.idx == rhs.idx) &&
      (lhs.parent_idx == rhs.parent_idx) &&
      (lhs.vars == rhs.vars) &&
      (lhs.ops == rhs.ops) &&
      (lhs.forward_block_idx == rhs.forward_block_idx);
}

inline bool operator!=(const BlockDescT &lhs, const BlockDescT &rhs) {
    return !(lhs == rhs);
}


struct BlockDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlockDescT NativeTableType;
  typedef BlockDescBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BlockDescTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDX = 4,
    VT_PARENT_IDX = 6,
    VT_VARS = 8,
    VT_OPS = 10,
    VT_FORWARD_BLOCK_IDX = 12
  };
  int32_t idx() const {
    return GetField<int32_t>(VT_IDX, 0);
  }
  bool mutate_idx(int32_t _idx) {
    return SetField<int32_t>(VT_IDX, _idx, 0);
  }
  int32_t parent_idx() const {
    return GetField<int32_t>(VT_PARENT_IDX, 0);
  }
  bool mutate_parent_idx(int32_t _parent_idx) {
    return SetField<int32_t>(VT_PARENT_IDX, _parent_idx, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>> *vars() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>> *>(VT_VARS);
  }
  flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>> *mutable_vars() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>> *>(VT_VARS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>> *ops() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>> *>(VT_OPS);
  }
  flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>> *mutable_ops() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>> *>(VT_OPS);
  }
  int32_t forward_block_idx() const {
    return GetField<int32_t>(VT_FORWARD_BLOCK_IDX, -1);
  }
  bool mutate_forward_block_idx(int32_t _forward_block_idx) {
    return SetField<int32_t>(VT_FORWARD_BLOCK_IDX, _forward_block_idx, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_IDX) &&
           VerifyField<int32_t>(verifier, VT_PARENT_IDX) &&
           VerifyOffset(verifier, VT_VARS) &&
           verifier.VerifyVector(vars()) &&
           verifier.VerifyVectorOfTables(vars()) &&
           VerifyOffset(verifier, VT_OPS) &&
           verifier.VerifyVector(ops()) &&
           verifier.VerifyVectorOfTables(ops()) &&
           VerifyField<int32_t>(verifier, VT_FORWARD_BLOCK_IDX) &&
           verifier.EndTable();
  }
  BlockDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlockDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BlockDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlockDescBuilder {
  typedef BlockDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx(int32_t idx) {
    fbb_.AddElement<int32_t>(BlockDesc::VT_IDX, idx, 0);
  }
  void add_parent_idx(int32_t parent_idx) {
    fbb_.AddElement<int32_t>(BlockDesc::VT_PARENT_IDX, parent_idx, 0);
  }
  void add_vars(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>>> vars) {
    fbb_.AddOffset(BlockDesc::VT_VARS, vars);
  }
  void add_ops(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>>> ops) {
    fbb_.AddOffset(BlockDesc::VT_OPS, ops);
  }
  void add_forward_block_idx(int32_t forward_block_idx) {
    fbb_.AddElement<int32_t>(BlockDesc::VT_FORWARD_BLOCK_IDX, forward_block_idx, -1);
  }
  explicit BlockDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlockDescBuilder &operator=(const BlockDescBuilder &);
  flatbuffers::Offset<BlockDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlockDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlockDesc> CreateBlockDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t idx = 0,
    int32_t parent_idx = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>>> vars = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>>> ops = 0,
    int32_t forward_block_idx = -1) {
  BlockDescBuilder builder_(_fbb);
  builder_.add_forward_block_idx(forward_block_idx);
  builder_.add_ops(ops);
  builder_.add_vars(vars);
  builder_.add_parent_idx(parent_idx);
  builder_.add_idx(idx);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlockDesc> CreateBlockDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t idx = 0,
    int32_t parent_idx = 0,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>> *vars = nullptr,
    const std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>> *ops = nullptr,
    int32_t forward_block_idx = -1) {
  auto vars__ = vars ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::proto::VarDesc>(vars) : 0;
  auto ops__ = ops ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>>(*ops) : 0;
  return paddle::lite::fbs::proto::CreateBlockDesc(
      _fbb,
      idx,
      parent_idx,
      vars__,
      ops__,
      forward_block_idx);
}

flatbuffers::Offset<BlockDesc> CreateBlockDesc(flatbuffers::FlatBufferBuilder &_fbb, const BlockDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OpVersionT : public flatbuffers::NativeTable {
  typedef OpVersion TableType;
  int32_t version;
  OpVersionT()
      : version(0) {
  }
};

inline bool operator==(const OpVersionT &lhs, const OpVersionT &rhs) {
  return
      (lhs.version == rhs.version);
}

inline bool operator!=(const OpVersionT &lhs, const OpVersionT &rhs) {
    return !(lhs == rhs);
}


struct OpVersion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpVersionT NativeTableType;
  typedef OpVersionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OpVersionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4
  };
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  bool mutate_version(int32_t _version) {
    return SetField<int32_t>(VT_VERSION, _version, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
  OpVersionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpVersionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OpVersion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OpVersionBuilder {
  typedef OpVersion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(OpVersion::VT_VERSION, version, 0);
  }
  explicit OpVersionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OpVersionBuilder &operator=(const OpVersionBuilder &);
  flatbuffers::Offset<OpVersion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpVersion>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpVersion> CreateOpVersion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0) {
  OpVersionBuilder builder_(_fbb);
  builder_.add_version(version);
  return builder_.Finish();
}

flatbuffers::Offset<OpVersion> CreateOpVersion(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OpVersionMapT : public flatbuffers::NativeTable {
  typedef OpVersionMap TableType;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPairT>> pair;
  OpVersionMapT() {
  }
};

inline bool operator==(const OpVersionMapT &lhs, const OpVersionMapT &rhs) {
  return
      (lhs.pair == rhs.pair);
}

inline bool operator!=(const OpVersionMapT &lhs, const OpVersionMapT &rhs) {
    return !(lhs == rhs);
}


struct OpVersionMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpVersionMapT NativeTableType;
  typedef OpVersionMapBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OpVersionMapTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAIR = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPair>> *pair() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPair>> *>(VT_PAIR);
  }
  flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPair>> *mutable_pair() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPair>> *>(VT_PAIR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAIR) &&
           verifier.VerifyVector(pair()) &&
           verifier.VerifyVectorOfTables(pair()) &&
           verifier.EndTable();
  }
  OpVersionMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpVersionMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OpVersionMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OpVersionMapBuilder {
  typedef OpVersionMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pair(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPair>>> pair) {
    fbb_.AddOffset(OpVersionMap::VT_PAIR, pair);
  }
  explicit OpVersionMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OpVersionMapBuilder &operator=(const OpVersionMapBuilder &);
  flatbuffers::Offset<OpVersionMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpVersionMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpVersionMap> CreateOpVersionMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPair>>> pair = 0) {
  OpVersionMapBuilder builder_(_fbb);
  builder_.add_pair(pair);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpVersionMap> CreateOpVersionMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPair>> *pair = nullptr) {
  auto pair__ = pair ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPair>(pair) : 0;
  return paddle::lite::fbs::proto::CreateOpVersionMap(
      _fbb,
      pair__);
}

flatbuffers::Offset<OpVersionMap> CreateOpVersionMap(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace OpVersionMap_ {

struct OpVersionPairT : public flatbuffers::NativeTable {
  typedef OpVersionPair TableType;
  std::string op_name;
  std::unique_ptr<paddle::lite::fbs::proto::OpVersionT> op_version;
  OpVersionPairT() {
  }
};

inline bool operator==(const OpVersionPairT &lhs, const OpVersionPairT &rhs) {
  return
      (lhs.op_name == rhs.op_name) &&
      (lhs.op_version == rhs.op_version);
}

inline bool operator!=(const OpVersionPairT &lhs, const OpVersionPairT &rhs) {
    return !(lhs == rhs);
}


struct OpVersionPair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpVersionPairT NativeTableType;
  typedef OpVersionPairBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OpVersionPairTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_NAME = 4,
    VT_OP_VERSION = 6
  };
  const flatbuffers::String *op_name() const {
    return GetPointer<const flatbuffers::String *>(VT_OP_NAME);
  }
  flatbuffers::String *mutable_op_name() {
    return GetPointer<flatbuffers::String *>(VT_OP_NAME);
  }
  bool KeyCompareLessThan(const OpVersionPair *o) const {
    return *op_name() < *o->op_name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(op_name()->c_str(), val);
  }
  const paddle::lite::fbs::proto::OpVersion *op_version() const {
    return GetPointer<const paddle::lite::fbs::proto::OpVersion *>(VT_OP_VERSION);
  }
  paddle::lite::fbs::proto::OpVersion *mutable_op_version() {
    return GetPointer<paddle::lite::fbs::proto::OpVersion *>(VT_OP_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OP_NAME) &&
           verifier.VerifyString(op_name()) &&
           VerifyOffsetRequired(verifier, VT_OP_VERSION) &&
           verifier.VerifyTable(op_version()) &&
           verifier.EndTable();
  }
  OpVersionPairT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpVersionPairT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OpVersionPair> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionPairT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OpVersionPairBuilder {
  typedef OpVersionPair Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_op_name(flatbuffers::Offset<flatbuffers::String> op_name) {
    fbb_.AddOffset(OpVersionPair::VT_OP_NAME, op_name);
  }
  void add_op_version(flatbuffers::Offset<paddle::lite::fbs::proto::OpVersion> op_version) {
    fbb_.AddOffset(OpVersionPair::VT_OP_VERSION, op_version);
  }
  explicit OpVersionPairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OpVersionPairBuilder &operator=(const OpVersionPairBuilder &);
  flatbuffers::Offset<OpVersionPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpVersionPair>(end);
    fbb_.Required(o, OpVersionPair::VT_OP_NAME);
    fbb_.Required(o, OpVersionPair::VT_OP_VERSION);
    return o;
  }
};

inline flatbuffers::Offset<OpVersionPair> CreateOpVersionPair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> op_name = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::OpVersion> op_version = 0) {
  OpVersionPairBuilder builder_(_fbb);
  builder_.add_op_version(op_version);
  builder_.add_op_name(op_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpVersionPair> CreateOpVersionPairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *op_name = nullptr,
    flatbuffers::Offset<paddle::lite::fbs::proto::OpVersion> op_version = 0) {
  auto op_name__ = op_name ? _fbb.CreateString(op_name) : 0;
  return paddle::lite::fbs::proto::OpVersionMap_::CreateOpVersionPair(
      _fbb,
      op_name__,
      op_version);
}

flatbuffers::Offset<OpVersionPair> CreateOpVersionPair(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionPairT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace OpVersionMap_

struct ProgramDescT : public flatbuffers::NativeTable {
  typedef ProgramDesc TableType;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::BlockDescT>> blocks;
  std::unique_ptr<paddle::lite::fbs::proto::VersionT> version;
  std::unique_ptr<paddle::lite::fbs::proto::OpVersionMapT> op_version_map;
  ProgramDescT() {
  }
};

inline bool operator==(const ProgramDescT &lhs, const ProgramDescT &rhs) {
  return
      (lhs.blocks == rhs.blocks) &&
      (lhs.version == rhs.version) &&
      (lhs.op_version_map == rhs.op_version_map);
}

inline bool operator!=(const ProgramDescT &lhs, const ProgramDescT &rhs) {
    return !(lhs == rhs);
}


struct ProgramDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgramDescT NativeTableType;
  typedef ProgramDescBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProgramDescTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKS = 4,
    VT_VERSION = 6,
    VT_OP_VERSION_MAP = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>> *blocks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>> *>(VT_BLOCKS);
  }
  flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>> *mutable_blocks() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>> *>(VT_BLOCKS);
  }
  const paddle::lite::fbs::proto::Version *version() const {
    return GetPointer<const paddle::lite::fbs::proto::Version *>(VT_VERSION);
  }
  paddle::lite::fbs::proto::Version *mutable_version() {
    return GetPointer<paddle::lite::fbs::proto::Version *>(VT_VERSION);
  }
  const paddle::lite::fbs::proto::OpVersionMap *op_version_map() const {
    return GetPointer<const paddle::lite::fbs::proto::OpVersionMap *>(VT_OP_VERSION_MAP);
  }
  paddle::lite::fbs::proto::OpVersionMap *mutable_op_version_map() {
    return GetPointer<paddle::lite::fbs::proto::OpVersionMap *>(VT_OP_VERSION_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKS) &&
           verifier.VerifyVector(blocks()) &&
           verifier.VerifyVectorOfTables(blocks()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyTable(version()) &&
           VerifyOffset(verifier, VT_OP_VERSION_MAP) &&
           verifier.VerifyTable(op_version_map()) &&
           verifier.EndTable();
  }
  ProgramDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProgramDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProgramDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgramDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProgramDescBuilder {
  typedef ProgramDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>>> blocks) {
    fbb_.AddOffset(ProgramDesc::VT_BLOCKS, blocks);
  }
  void add_version(flatbuffers::Offset<paddle::lite::fbs::proto::Version> version) {
    fbb_.AddOffset(ProgramDesc::VT_VERSION, version);
  }
  void add_op_version_map(flatbuffers::Offset<paddle::lite::fbs::proto::OpVersionMap> op_version_map) {
    fbb_.AddOffset(ProgramDesc::VT_OP_VERSION_MAP, op_version_map);
  }
  explicit ProgramDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProgramDescBuilder &operator=(const ProgramDescBuilder &);
  flatbuffers::Offset<ProgramDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProgramDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProgramDesc> CreateProgramDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>>> blocks = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::Version> version = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::OpVersionMap> op_version_map = 0) {
  ProgramDescBuilder builder_(_fbb);
  builder_.add_op_version_map(op_version_map);
  builder_.add_version(version);
  builder_.add_blocks(blocks);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProgramDesc> CreateProgramDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>> *blocks = nullptr,
    flatbuffers::Offset<paddle::lite::fbs::proto::Version> version = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::OpVersionMap> op_version_map = 0) {
  auto blocks__ = blocks ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>>(*blocks) : 0;
  return paddle::lite::fbs::proto::CreateProgramDesc(
      _fbb,
      blocks__,
      version,
      op_version_map);
}

flatbuffers::Offset<ProgramDesc> CreateProgramDesc(flatbuffers::FlatBufferBuilder &_fbb, const ProgramDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline VersionT *Version::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VersionT> _o = std::unique_ptr<paddle::lite::fbs::proto::VersionT>(new VersionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Version::UnPackTo(VersionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); _o->version = _e; }
}

inline flatbuffers::Offset<Version> Version::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VersionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVersion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Version> CreateVersion(flatbuffers::FlatBufferBuilder &_fbb, const VersionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VersionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version;
  return paddle::lite::fbs::proto::CreateVersion(
      _fbb,
      _version);
}

inline OpDescT *OpDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::OpDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::OpDescT>(new OpDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OpDesc::UnPackTo(OpDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = attrs(); if (_e) { _o->attrs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attrs[_i] = std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::AttrT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = is_target(); _o->is_target = _e; }
}

inline flatbuffers::Offset<OpDesc> OpDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOpDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OpDesc> CreateOpDesc(flatbuffers::FlatBufferBuilder &_fbb, const OpDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _fbb.CreateString(_o->type);
  auto _inputs = _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> (_o->inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateVar(*__va->__fbb, __va->__o->inputs[i].get(), __va->__rehasher); }, &_va );
  auto _outputs = _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> (_o->outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateVar(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher); }, &_va );
  auto _attrs = _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>> (_o->attrs.size(), [](size_t i, _VectorArgs *__va) { return CreateAttr(*__va->__fbb, __va->__o->attrs[i].get(), __va->__rehasher); }, &_va );
  auto _is_target = _o->is_target;
  return paddle::lite::fbs::proto::CreateOpDesc(
      _fbb,
      _type,
      _inputs,
      _outputs,
      _attrs,
      _is_target);
}

namespace OpDesc_ {

inline AttrT *Attr::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::AttrT> _o = std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::AttrT>(new AttrT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Attr::UnPackTo(AttrT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = type(); _o->type = _e; }
  { auto _e = i(); _o->i = _e; }
  { auto _e = f(); _o->f = _e; }
  { auto _e = s(); if (_e) _o->s = _e->str(); }
  { auto _e = ints(); if (_e) { _o->ints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ints[_i] = _e->Get(_i); } } }
  { auto _e = floats(); if (_e) { _o->floats.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->floats[_i] = _e->Get(_i); } } }
  { auto _e = strings(); if (_e) { _o->strings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strings[_i] = _e->Get(_i)->str(); } } }
  { auto _e = b(); _o->b = _e; }
  { auto _e = bools(); if (_e) { _o->bools.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bools[_i] = _e->Get(_i) != 0; } } }
  { auto _e = block_idx(); _o->block_idx = _e; }
  { auto _e = l(); _o->l = _e; }
  { auto _e = blocks_idx(); if (_e) { _o->blocks_idx.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->blocks_idx[_i] = _e->Get(_i); } } }
  { auto _e = longs(); if (_e) { _o->longs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->longs[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Attr> Attr::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttrT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttr(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Attr> CreateAttr(flatbuffers::FlatBufferBuilder &_fbb, const AttrT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttrT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _i = _o->i;
  auto _f = _o->f;
  auto _s = _o->s.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->s);
  auto _ints = _fbb.CreateVector(_o->ints);
  auto _floats = _fbb.CreateVector(_o->floats);
  auto _strings = _fbb.CreateVectorOfStrings(_o->strings);
  auto _b = _o->b;
  auto _bools = _fbb.CreateVector(_o->bools);
  auto _block_idx = _o->block_idx;
  auto _l = _o->l;
  auto _blocks_idx = _fbb.CreateVector(_o->blocks_idx);
  auto _longs = _fbb.CreateVector(_o->longs);
  return paddle::lite::fbs::proto::OpDesc_::CreateAttr(
      _fbb,
      _name,
      _type,
      _i,
      _f,
      _s,
      _ints,
      _floats,
      _strings,
      _b,
      _bools,
      _block_idx,
      _l,
      _blocks_idx,
      _longs);
}

inline VarT *Var::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT> _o = std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT>(new VarT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Var::UnPackTo(VarT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = parameter(); if (_e) _o->parameter = _e->str(); }
  { auto _e = arguments(); if (_e) { _o->arguments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->arguments[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<Var> Var::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVar(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Var> CreateVar(flatbuffers::FlatBufferBuilder &_fbb, const VarT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VarT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _parameter = _fbb.CreateString(_o->parameter);
  auto _arguments = _fbb.CreateVectorOfStrings(_o->arguments);
  return paddle::lite::fbs::proto::OpDesc_::CreateVar(
      _fbb,
      _parameter,
      _arguments);
}

}  // namespace OpDesc_

inline VarTypeT *VarType::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarTypeT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarTypeT>(new VarTypeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VarType::UnPackTo(VarTypeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = selected_rows(); if (_e) _o->selected_rows = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT>(_e->UnPack(_resolver)); }
  { auto _e = lod_tensor(); if (_e) _o->lod_tensor = std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT>(_e->UnPack(_resolver)); }
  { auto _e = tensor_array(); if (_e) _o->tensor_array = std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDescT>(_e->UnPack(_resolver)); }
  { auto _e = reader(); if (_e) _o->reader = std::unique_ptr<paddle::lite::fbs::proto::VarType_::ReaderDescT>(_e->UnPack(_resolver)); }
  { auto _e = tuple(); if (_e) _o->tuple = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TupleT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<VarType> VarType::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarTypeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVarType(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VarType> CreateVarType(flatbuffers::FlatBufferBuilder &_fbb, const VarTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VarTypeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _selected_rows = _o->selected_rows ? CreateTensorDesc(_fbb, _o->selected_rows.get(), _rehasher) : 0;
  auto _lod_tensor = _o->lod_tensor ? CreateLoDTensorDesc(_fbb, _o->lod_tensor.get(), _rehasher) : 0;
  auto _tensor_array = _o->tensor_array ? CreateLoDTensorArrayDesc(_fbb, _o->tensor_array.get(), _rehasher) : 0;
  auto _reader = _o->reader ? CreateReaderDesc(_fbb, _o->reader.get(), _rehasher) : 0;
  auto _tuple = _o->tuple ? CreateTuple(_fbb, _o->tuple.get(), _rehasher) : 0;
  return paddle::lite::fbs::proto::CreateVarType(
      _fbb,
      _type,
      _selected_rows,
      _lod_tensor,
      _tensor_array,
      _reader,
      _tuple);
}

namespace VarType_ {

inline TensorDescT *TensorDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT>(new TensorDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorDesc::UnPackTo(TensorDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data_type(); _o->data_type = _e; }
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<TensorDesc> TensorDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorDesc> CreateTensorDesc(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data_type = _o->data_type;
  auto _dims = _fbb.CreateVector(_o->dims);
  return paddle::lite::fbs::proto::VarType_::CreateTensorDesc(
      _fbb,
      _data_type,
      _dims);
}

inline LoDTensorDescT *LoDTensorDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT>(new LoDTensorDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LoDTensorDesc::UnPackTo(LoDTensorDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensor(); if (_e) _o->tensor = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT>(_e->UnPack(_resolver)); }
  { auto _e = lod_level(); _o->lod_level = _e; }
}

inline flatbuffers::Offset<LoDTensorDesc> LoDTensorDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoDTensorDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoDTensorDesc> CreateLoDTensorDesc(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoDTensorDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensor = _o->tensor ? CreateTensorDesc(_fbb, _o->tensor.get(), _rehasher) : 0;
  auto _lod_level = _o->lod_level;
  return paddle::lite::fbs::proto::VarType_::CreateLoDTensorDesc(
      _fbb,
      _tensor,
      _lod_level);
}

inline LoDTensorArrayDescT *LoDTensorArrayDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDescT>(new LoDTensorArrayDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LoDTensorArrayDesc::UnPackTo(LoDTensorArrayDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensor(); if (_e) _o->tensor = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT>(_e->UnPack(_resolver)); }
  { auto _e = lod_level(); _o->lod_level = _e; }
}

inline flatbuffers::Offset<LoDTensorArrayDesc> LoDTensorArrayDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorArrayDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoDTensorArrayDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoDTensorArrayDesc> CreateLoDTensorArrayDesc(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorArrayDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoDTensorArrayDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensor = _o->tensor ? CreateTensorDesc(_fbb, _o->tensor.get(), _rehasher) : 0;
  auto _lod_level = _o->lod_level;
  return paddle::lite::fbs::proto::VarType_::CreateLoDTensorArrayDesc(
      _fbb,
      _tensor,
      _lod_level);
}

inline ReaderDescT *ReaderDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::ReaderDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarType_::ReaderDescT>(new ReaderDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReaderDesc::UnPackTo(ReaderDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lod_tensor(); if (_e) { _o->lod_tensor.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lod_tensor[_i] = std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<ReaderDesc> ReaderDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReaderDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReaderDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReaderDesc> CreateReaderDesc(flatbuffers::FlatBufferBuilder &_fbb, const ReaderDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReaderDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lod_tensor = _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>> (_o->lod_tensor.size(), [](size_t i, _VectorArgs *__va) { return CreateLoDTensorDesc(*__va->__fbb, __va->__o->lod_tensor[i].get(), __va->__rehasher); }, &_va );
  return paddle::lite::fbs::proto::VarType_::CreateReaderDesc(
      _fbb,
      _lod_tensor);
}

inline TupleT *Tuple::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TupleT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TupleT>(new TupleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tuple::UnPackTo(TupleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = element_type(); if (_e) { _o->element_type.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->element_type[_i] = static_cast<paddle::lite::fbs::proto::VarType_::Type>(_e->Get(_i)); } } }
}

inline flatbuffers::Offset<Tuple> Tuple::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TupleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTuple(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tuple> CreateTuple(flatbuffers::FlatBufferBuilder &_fbb, const TupleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TupleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _element_type = _fbb.CreateVectorScalarCast<int32_t>(flatbuffers::data(_o->element_type), _o->element_type.size());
  return paddle::lite::fbs::proto::VarType_::CreateTuple(
      _fbb,
      _element_type);
}

}  // namespace VarType_

inline VarDescT *VarDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarDescT>(new VarDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VarDesc::UnPackTo(VarDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = type(); if (_e) _o->type = std::unique_ptr<paddle::lite::fbs::proto::VarTypeT>(_e->UnPack(_resolver)); }
  { auto _e = persistable(); _o->persistable = _e; }
  { auto _e = need_check_feed(); _o->need_check_feed = _e; }
}

inline flatbuffers::Offset<VarDesc> VarDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVarDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VarDesc> CreateVarDesc(flatbuffers::FlatBufferBuilder &_fbb, const VarDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VarDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _fbb.CreateString(_o->name);
  auto _type = _o->type ? CreateVarType(_fbb, _o->type.get(), _rehasher) : 0;
  auto _persistable = _o->persistable;
  auto _need_check_feed = _o->need_check_feed;
  return paddle::lite::fbs::proto::CreateVarDesc(
      _fbb,
      _name,
      _type,
      _persistable,
      _need_check_feed);
}

inline BlockDescT *BlockDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::BlockDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::BlockDescT>(new BlockDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BlockDesc::UnPackTo(BlockDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = idx(); _o->idx = _e; }
  { auto _e = parent_idx(); _o->parent_idx = _e; }
  { auto _e = vars(); if (_e) { _o->vars.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vars[_i] = std::unique_ptr<paddle::lite::fbs::proto::VarDescT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = ops(); if (_e) { _o->ops.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ops[_i] = std::unique_ptr<paddle::lite::fbs::proto::OpDescT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = forward_block_idx(); _o->forward_block_idx = _e; }
}

inline flatbuffers::Offset<BlockDesc> BlockDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlockDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BlockDesc> CreateBlockDesc(flatbuffers::FlatBufferBuilder &_fbb, const BlockDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BlockDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _idx = _o->idx;
  auto _parent_idx = _o->parent_idx;
  auto _vars = _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>> (_o->vars.size(), [](size_t i, _VectorArgs *__va) { return CreateVarDesc(*__va->__fbb, __va->__o->vars[i].get(), __va->__rehasher); }, &_va );
  auto _ops = _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>> (_o->ops.size(), [](size_t i, _VectorArgs *__va) { return CreateOpDesc(*__va->__fbb, __va->__o->ops[i].get(), __va->__rehasher); }, &_va );
  auto _forward_block_idx = _o->forward_block_idx;
  return paddle::lite::fbs::proto::CreateBlockDesc(
      _fbb,
      _idx,
      _parent_idx,
      _vars,
      _ops,
      _forward_block_idx);
}

inline OpVersionT *OpVersion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::OpVersionT> _o = std::unique_ptr<paddle::lite::fbs::proto::OpVersionT>(new OpVersionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OpVersion::UnPackTo(OpVersionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); _o->version = _e; }
}

inline flatbuffers::Offset<OpVersion> OpVersion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOpVersion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OpVersion> CreateOpVersion(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpVersionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version;
  return paddle::lite::fbs::proto::CreateOpVersion(
      _fbb,
      _version);
}

inline OpVersionMapT *OpVersionMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::OpVersionMapT> _o = std::unique_ptr<paddle::lite::fbs::proto::OpVersionMapT>(new OpVersionMapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OpVersionMap::UnPackTo(OpVersionMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pair(); if (_e) { _o->pair.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pair[_i] = std::unique_ptr<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPairT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<OpVersionMap> OpVersionMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOpVersionMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OpVersionMap> CreateOpVersionMap(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpVersionMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pair = _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPair>> (_o->pair.size(), [](size_t i, _VectorArgs *__va) { return CreateOpVersionPair(*__va->__fbb, __va->__o->pair[i].get(), __va->__rehasher); }, &_va );
  return paddle::lite::fbs::proto::CreateOpVersionMap(
      _fbb,
      _pair);
}

namespace OpVersionMap_ {

inline OpVersionPairT *OpVersionPair::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPairT> _o = std::unique_ptr<paddle::lite::fbs::proto::OpVersionMap_::OpVersionPairT>(new OpVersionPairT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OpVersionPair::UnPackTo(OpVersionPairT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = op_name(); if (_e) _o->op_name = _e->str(); }
  { auto _e = op_version(); if (_e) _o->op_version = std::unique_ptr<paddle::lite::fbs::proto::OpVersionT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<OpVersionPair> OpVersionPair::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionPairT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOpVersionPair(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OpVersionPair> CreateOpVersionPair(flatbuffers::FlatBufferBuilder &_fbb, const OpVersionPairT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpVersionPairT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _op_name = _fbb.CreateString(_o->op_name);
  auto _op_version = _o->op_version ? CreateOpVersion(_fbb, _o->op_version.get(), _rehasher) : 0;
  return paddle::lite::fbs::proto::OpVersionMap_::CreateOpVersionPair(
      _fbb,
      _op_name,
      _op_version);
}

}  // namespace OpVersionMap_

inline ProgramDescT *ProgramDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT>(new ProgramDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProgramDesc::UnPackTo(ProgramDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blocks(); if (_e) { _o->blocks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->blocks[_i] = std::unique_ptr<paddle::lite::fbs::proto::BlockDescT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = version(); if (_e) _o->version = std::unique_ptr<paddle::lite::fbs::proto::VersionT>(_e->UnPack(_resolver)); }
  { auto _e = op_version_map(); if (_e) _o->op_version_map = std::unique_ptr<paddle::lite::fbs::proto::OpVersionMapT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<ProgramDesc> ProgramDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgramDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProgramDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProgramDesc> CreateProgramDesc(flatbuffers::FlatBufferBuilder &_fbb, const ProgramDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProgramDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blocks = _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>> (_o->blocks.size(), [](size_t i, _VectorArgs *__va) { return CreateBlockDesc(*__va->__fbb, __va->__o->blocks[i].get(), __va->__rehasher); }, &_va );
  auto _version = _o->version ? CreateVersion(_fbb, _o->version.get(), _rehasher) : 0;
  auto _op_version_map = _o->op_version_map ? CreateOpVersionMap(_fbb, _o->op_version_map.get(), _rehasher) : 0;
  return paddle::lite::fbs::proto::CreateProgramDesc(
      _fbb,
      _blocks,
      _version,
      _op_version_map);
}

inline const flatbuffers::TypeTable *AttrTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::AttrTypeTypeTable
  };
  static const char * const names[] = {
    "INT",
    "FLOAT",
    "STRING",
    "INTS",
    "FLOATS",
    "STRINGS",
    "BOOLEAN",
    "BOOLEANS",
    "BLOCK",
    "LONG",
    "BLOCKS",
    "LONGS"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 12, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

namespace VarType_ {

inline const flatbuffers::TypeTable *TypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::VarType_::TypeTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21 };
  static const char * const names[] = {
    "BOOL",
    "INT16",
    "INT32",
    "INT64",
    "FP16",
    "FP32",
    "FP64",
    "LOD_TENSOR",
    "SELECTED_ROWS",
    "FEED_MINIBATCH",
    "FETCH_LIST",
    "STEP_SCOPES",
    "LOD_RANK_TABLE",
    "LOD_TENSOR_ARRAY",
    "PLACE_LIST",
    "READER",
    "RAW",
    "TUPLE",
    "SIZE_T",
    "UINT8",
    "INT8"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 21, type_codes, type_refs, values, names
  };
  return &tt;
}

}  // namespace VarType_

namespace CompatibleInfo_ {

inline const flatbuffers::TypeTable *TypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::CompatibleInfo_::TypeTypeTable
  };
  static const char * const names[] = {
    "COMPATIBLE",
    "DEFINITELY_NOT",
    "POSSIBLE",
    "BUG_FIX",
    "PRECISION_CHANGE"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace CompatibleInfo_

inline const flatbuffers::TypeTable *VersionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "version"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpDescTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::OpDesc_::VarTypeTable,
    paddle::lite::fbs::proto::OpDesc_::AttrTypeTable
  };
  static const char * const names[] = {
    "type",
    "inputs",
    "outputs",
    "attrs",
    "is_target"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

namespace OpDesc_ {

inline const flatbuffers::TypeTable *AttrTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::AttrTypeTypeTable
  };
  static const char * const names[] = {
    "name",
    "type",
    "i",
    "f",
    "s",
    "ints",
    "floats",
    "strings",
    "b",
    "bools",
    "block_idx",
    "l",
    "blocks_idx",
    "longs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 14, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VarTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "parameter",
    "arguments"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace OpDesc_

inline const flatbuffers::TypeTable *VarTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::VarType_::TypeTypeTable,
    paddle::lite::fbs::proto::VarType_::TensorDescTypeTable,
    paddle::lite::fbs::proto::VarType_::LoDTensorDescTypeTable,
    paddle::lite::fbs::proto::VarType_::LoDTensorArrayDescTypeTable,
    paddle::lite::fbs::proto::VarType_::ReaderDescTypeTable,
    paddle::lite::fbs::proto::VarType_::TupleTypeTable
  };
  static const char * const names[] = {
    "type",
    "selected_rows",
    "lod_tensor",
    "tensor_array",
    "reader",
    "tuple"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

namespace VarType_ {

inline const flatbuffers::TypeTable *TensorDescTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::VarType_::TypeTypeTable
  };
  static const char * const names[] = {
    "data_type",
    "dims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LoDTensorDescTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::VarType_::TensorDescTypeTable
  };
  static const char * const names[] = {
    "tensor",
    "lod_level"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LoDTensorArrayDescTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::VarType_::TensorDescTypeTable
  };
  static const char * const names[] = {
    "tensor",
    "lod_level"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReaderDescTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::VarType_::LoDTensorDescTypeTable
  };
  static const char * const names[] = {
    "lod_tensor"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TupleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::VarType_::TypeTypeTable
  };
  static const char * const names[] = {
    "element_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace VarType_

inline const flatbuffers::TypeTable *VarDescTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::VarTypeTypeTable
  };
  static const char * const names[] = {
    "name",
    "type",
    "persistable",
    "need_check_feed"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlockDescTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::VarDescTypeTable,
    paddle::lite::fbs::proto::OpDescTypeTable
  };
  static const char * const names[] = {
    "idx",
    "parent_idx",
    "vars",
    "ops",
    "forward_block_idx"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpVersionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "version"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpVersionMapTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::OpVersionMap_::OpVersionPairTypeTable
  };
  static const char * const names[] = {
    "pair"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

namespace OpVersionMap_ {

inline const flatbuffers::TypeTable *OpVersionPairTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::OpVersionTypeTable
  };
  static const char * const names[] = {
    "op_name",
    "op_version"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace OpVersionMap_

inline const flatbuffers::TypeTable *ProgramDescTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    paddle::lite::fbs::proto::BlockDescTypeTable,
    paddle::lite::fbs::proto::VersionTypeTable,
    paddle::lite::fbs::proto::OpVersionMapTypeTable
  };
  static const char * const names[] = {
    "blocks",
    "version",
    "op_version_map"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const paddle::lite::fbs::proto::ProgramDesc *GetProgramDesc(const void *buf) {
  return flatbuffers::GetRoot<paddle::lite::fbs::proto::ProgramDesc>(buf);
}

inline const paddle::lite::fbs::proto::ProgramDesc *GetSizePrefixedProgramDesc(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<paddle::lite::fbs::proto::ProgramDesc>(buf);
}

inline ProgramDesc *GetMutableProgramDesc(void *buf) {
  return flatbuffers::GetMutableRoot<ProgramDesc>(buf);
}

inline bool VerifyProgramDescBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<paddle::lite::fbs::proto::ProgramDesc>(nullptr);
}

inline bool VerifySizePrefixedProgramDescBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<paddle::lite::fbs::proto::ProgramDesc>(nullptr);
}

inline void FinishProgramDescBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<paddle::lite::fbs::proto::ProgramDesc> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedProgramDescBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<paddle::lite::fbs::proto::ProgramDesc> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT> UnPackProgramDesc(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT>(GetProgramDesc(buf)->UnPack(res));
}

inline std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT> UnPackSizePrefixedProgramDesc(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT>(GetSizePrefixedProgramDesc(buf)->UnPack(res));
}

}  // namespace proto
}  // namespace fbs
}  // namespace lite
}  // namespace paddle

#endif  // FLATBUFFERS_GENERATED_FRAMEWORK_PADDLE_LITE_FBS_PROTO_H_
